<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hyaena</title>

    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#e3dac9">
    <link rel="apple-touch-icon" href="icon.png">

    <style>
        /* --- THEME VARIABLES --- */
        :root {
            --bg-body: #f2f2f7;
            --bg-sidebar: #ffffff;
            --bg-toolbar: #ffffff;
            --text-main: #000000;
            --text-sec: #666666;
            --border: #ccc;
            --item-hover: #f0f0f5;
            --input-bg: #e5e5ea;
            --modal-bg: #ffffff;
            --accent: #007aff;
            --viewport-bg: #444;
        }

        [data-theme="dark"] {
            --bg-body: #000000;
            --bg-sidebar: #1c1c1e;
            --bg-toolbar: #1c1c1e;
            --text-main: #ffffff;
            --text-sec: #aaaaaa;
            --border: #38383a;
            --item-hover: #2c2c2e;
            --input-bg: #2c2c2e;
            --modal-bg: #2c2c2e;
            --accent: #0a84ff;
        }

        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg-body);
            color: var(--text-main);
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            overscroll-behavior-y: none;
        }

        /* --- MAIN MENU --- */
        #mainMenu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg-body);
            z-index: 3000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            text-align: center;
            transition: transform 0.3s ease-in-out;
        }

        #mainMenu.hidden {
            transform: translateY(-100%);
            pointer-events: none;
        }

        .app-logo {
            width: 100px;
            height: 100px;
            border-radius: 20px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        .app-title {
            font-size: 28px;
            font-weight: 800;
            margin-bottom: 30px;
        }

        .menu-btn {
            width: 250px;
            padding: 15px;
            margin: 8px 0;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .menu-btn.secondary {
            background: var(--input-bg);
            color: var(--text-main);
        }

        .version-footer {
            position: absolute;
            bottom: 50px;
            font-size: 13px;
            color: var(--text-sec);
            opacity: 0.7;
        }

        #settingsPanel {
            display: none;
            flex-direction: column;
            gap: 15px;
            background: var(--bg-sidebar);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
            margin-top: 20px;
            width: 280px;
            border: 1px solid var(--border);
        }

        .theme-opt {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            background: var(--input-bg);
            border-radius: 8px;
            cursor: pointer;
        }

        .theme-opt.selected {
            border: 2px solid var(--accent);
        }

        /* --- APP LAYOUT --- */
        #mainContainer {
            display: flex;
            flex-grow: 1;
            overflow: hidden;
            height: 100%;
            position: relative;
        }

        #sidebar {
            width: 280px;
            background: var(--bg-sidebar);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            transition: width 0.3s, transform 0.3s;
            z-index: 1500;
        }

        #sidebar.collapsed {
            width: 0;
            overflow: hidden;
            border: none;
        }

        #sidebar.fullscreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-right: none;
        }

        #projectHeader {
            padding: 15px 12px;
            background: var(--input-bg);
            border-bottom: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        #projectTitleRow {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #projNameDisplay {
            font-weight: bold;
            font-size: 16px;
            color: var(--accent);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        #samplesHeader {
            padding: 8px 12px;
            background: var(--bg-toolbar);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-sec);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border);
        }

        .btn-mini {
            background: transparent;
            border: 1px solid var(--border);
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
            padding: 2px 6px;
            color: var(--text-main);
        }

        #sampleList {
            flex-grow: 1;
            overflow-y: auto;
            padding: 0;
            margin: 0;
            list-style: none;
        }

        .sample-item {
            padding: 12px;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            font-size: 13px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: var(--text-main);
        }

        .list-header {
            padding: 8px 12px;
            background: var(--bg-toolbar);
            font-weight: bold;
            font-size: 11px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 1px solid var(--border);
            border-top: 1px solid var(--border);
            margin-top: -1px;
            position: sticky;
            top: 0;
        }



        .sample-item:hover {
            background: var(--item-hover);
        }

        .sample-item.drag-over {
            border-top: 2px solid var(--accent);
        }

        .sample-item.dragging {
            opacity: 0.4;
        }

        .sample-item.active {
            background: var(--accent);
            color: white;
        }

        .sample-item.active .sample-stats {
            color: rgba(255, 255, 255, 0.8);
        }

        .sample-info {
            flex-grow: 1;
            overflow: hidden;
            padding-right: 5px;
        }

        .sample-stats {
            font-size: 11px;
            color: var(--text-sec);
            margin-top: 4px;
            line-height: 1.4;
            white-space: normal;
        }

        .sample-warning {
            color: #ff9f0a;
            font-size: 10px;
            display: none;
            margin-top: 2px;
        }

        .no-img .sample-warning {
            display: block;
        }

        .btn-icon-small {
            background: none;
            border: none;
            color: inherit;
            opacity: 0.6;
            font-size: 16px;
            padding: 6px;
            cursor: pointer;
        }

        .btn-icon-small:hover {
            opacity: 1;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
        }

        #workArea {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
        }

        #toolbar {
            flex-shrink: 0;
            background: var(--bg-toolbar);
            padding: 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 8px;
            border-bottom: 1px solid var(--border);
        }

        .row {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 6px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: var(--input-bg);
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            color: var(--text-main);
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .btn.active {
            background-color: var(--accent);
            color: white;
            border-color: var(--accent);
        }

        .btn-green {
            background-color: #34c759;
            color: white;
            border: none;
        }

        .btn-blue {
            background-color: #007aff;
            color: white;
            border: none;
        }

        .btn-purple {
            background-color: #af52de;
            color: white;
            border: none;
        }

        .btn-red {
            background-color: #ff3b30;
            color: white;
            border: none;
        }

        .btn-calib {
            background-color: #ff9500;
            color: white;
            border: none;
        }

        .btn-excel {
            background-color: #1d6f42;
            color: white;
            border: none;
        }

        .btn-doubt-mode {
            border: 2px solid #ffd60a;
            background: transparent;
            color: #b48900;
        }

        [data-theme="dark"] .btn-doubt-mode {
            color: #ffd60a;
        }

        .btn-doubt-mode.active {
            background: #ffd60a;
            color: #000;
            animation: pulse 2s infinite;
        }

        .file-label {
            padding: 6px 10px;
            border-radius: 6px;
            background: var(--input-bg);
            font-size: 12px;
            cursor: pointer;
            border: 1px solid var(--border);
            color: var(--text-main);
        }

        #zoomContainer {
            display: flex;
            align-items: center;
            gap: 5px;
            background: var(--input-bg);
            padding: 4px 8px;
            border-radius: 15px;
            border: 1px solid var(--border);
        }

        #stats-bar {
            background: var(--bg-toolbar);
            padding: 6px;
            font-size: 12px;
            font-weight: 600;
            border-bottom: 1px solid var(--border);
            text-align: center;
            color: var(--text-main);
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 12px;
        }

        #viewport {
            flex-grow: 1;
            overflow: auto;
            position: relative;
            background-color: var(--viewport-bg);
            display: flex;
            touch-action: none;
            -webkit-overflow-scrolling: touch;
        }

        canvas {
            display: block;
            background: white;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
            margin: auto;
        }

        .mode-pan canvas {
            cursor: grab;
        }

        .mode-draw canvas {
            cursor: crosshair;
        }

        .mode-select canvas {
            cursor: pointer;
        }

        #doubtOverlayMsg {
            position: fixed;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 214, 10, 0.95);
            color: black;
            padding: 8px 20px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 13px;
            pointer-events: none;
            display: none;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            z-index: 500;
            border: 1px solid #b48900;
        }

        #noImageMsg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.7);
            text-align: center;
            font-weight: bold;
            display: none;
            cursor: pointer;
            padding: 20px;
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 10px;
        }

        #noImageMsg:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.6);
        }

        #modalOverlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        #modalBox {
            background: var(--modal-bg);
            color: var(--text-main);
            padding: 20px;
            border-radius: 12px;
            width: 90%;
            max-width: 350px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            text-align: center;
        }

        .modal-section {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border);
        }

        .inp-num {
            padding: 8px;
            width: 80px;
            border: 1px solid var(--border);
            border-radius: 4px;
            font-size: 16px;
            background: var(--input-bg);
            color: var(--text-main);
        }

        .inp-sel {
            padding: 8px;
            border: 1px solid var(--border);
            border-radius: 4px;
            font-size: 16px;
            background: var(--input-bg);
            color: var(--text-main);
        }

        .inp-sel-wide {
            padding: 10px;
            width: 100%;
            border: 1px solid var(--border);
            border-radius: 6px;
            font-size: 16px;
            background: var(--input-bg);
            color: var(--text-main);
            box-sizing: border-box;
            appearance: none;
            -webkit-appearance: none;
        }

        .inp-text-wide {
            padding: 10px;
            width: 100%;
            border: 1px solid var(--border);
            border-radius: 6px;
            font-size: 16px;
            background: var(--input-bg);
            color: var(--text-main);
            box-sizing: border-box;
        }

        /* --- HEADER LAYOUT --- */
        #toolbar {
            flex-direction: column;
            gap: 0;
            padding: 0;
        }

        .header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: var(--bg-toolbar);
            border-bottom: 1px solid var(--border);
            height: 50px;
        }

        .header-left,
        .header-right {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
        }

        .header-right {
            justify-content: flex-end;
        }

        .header-center {
            font-weight: bold;
            font-size: 16px;
            color: var(--text-main);
            text-align: center;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            max-width: 40%;
        }

        /* --- DROPDOWNS --- */
        .dropdown {
            position: relative;
            display: inline-block;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            background-color: var(--modal-bg);
            min-width: 200px;
            box-shadow: 0 8px 16px 0 rgba(0, 0, 0, 0.2);
            z-index: 2000;
            border-radius: 8px;
            border: 1px solid var(--border);
            top: 100%;
            margin-top: 5px;
        }

        .header-right .dropdown-content {
            right: 0;
        }

        .dropdown-content div,
        .dropdown-content label {
            color: var(--text-main);
            padding: 12px 16px;
            text-decoration: none;
            display: block;
            cursor: pointer;
            border-bottom: 1px solid var(--border);
            font-size: 14px;
        }

        .dropdown-content div:last-child {
            border-bottom: none;
        }

        .dropdown-content div:hover,
        .dropdown-content label:hover {
            background-color: var(--item-hover);
        }

        .show {
            display: block;
        }

        /* --- TOOLS ROW --- */
        .tools-container {
            display: flex;
            justify-content: center;
            gap: 15px;
            padding: 8px;
            background: var(--input-bg);
            border-bottom: 1px solid var(--border);
            flex-wrap: wrap;
        }
    </style>
</head>

<body>

    <div id="mainMenu">
        <img src="icon.png" alt="Icon" class="app-logo">
        <div class="app-title">Hyaena</div>

        <button class="menu-btn" onclick="startApp()"><span>‚û§</span> Start New Session</button>
        <button class="menu-btn secondary" onclick="triggerLoadProject()"><span>üìÇ</span> Load/Import Project</button>
        <button class="menu-btn secondary" onclick="toggleSettings()"><span>‚öôÔ∏è</span> Settings</button>

        <div id="settingsPanel">
            <div style="font-weight:bold; margin-bottom:10px;">Appearance</div>
            <div class="theme-opt" onclick="setTheme('light')" id="themeLight">‚òÄÔ∏è Light</div>
            <div class="theme-opt" onclick="setTheme('dark')" id="themeDark">üåô Dark</div>
            <div class="theme-opt" onclick="setTheme('auto')" id="themeAuto">üîÑ Auto (System)</div>
            <button class="btn btn-blue" style="width:100%; margin-top:10px;" onclick="toggleSettings()">Done</button>
        </div>

        <div class="version-footer">Version 0.23.3 (Beta)</div>
    </div>

    <div id="mainContainer">

        <div id="sidebar">
            <div id="projectHeader">
                <div style="font-size:10px; color:var(--text-sec); margin-bottom:2px;">CURRENT PROJECT</div>
                <div id="projectTitleRow">
                    <span id="projNameDisplay">Project_Results</span>
                    <button class="btn-icon-small" onclick="renameProject()" title="Rename Project">‚úé</button>
                </div>
            </div>
            <div id="samplesHeader">
                <span>Samples</span>
                <div style="display:flex; gap:5px;">
                    <button class="btn-mini" onclick="sortSamplesAZ()" title="Sort AZ inside groups">AZ</button>
                    <button class="btn-mini" onclick="createNewSample(true)">+ NEW</button>
                    <button class="btn" style="padding:2px 6px; font-size:14px;" onclick="toggleSidebarFullscreen()"
                        title="Expand">‚§¢</button>
                </div>
            </div>
            <ul id="sampleList"></ul>
        </div>

        <div id="workArea">
            <div id="toolbar">
                <!-- ROW 1: HEADER (Menu | Title | Output) -->
                <div class="header-row">
                    <div class="header-left">
                        <div class="dropdown">
                            <button class="btn" onclick="toggleDropdown('menuDropdown')">‚â° Menu</button>
                            <div id="menuDropdown" class="dropdown-content">
                                <div onclick="toggleSidebar()">‚ó´ Show/Hide List</div>
                                <label for="inpFile">üì∑ Load Image</label>
                                <label for="inpProject">üìÇ Import Project</label>
                                <div onclick="openImportModal()">üìÇ Batch Import Samples</div>
                                <div onclick="saveSingleSample()">üíæ Save Sample (.json)</div>
                                <div onclick="saveProject()">üìö Save Project (.json)</div>
                                <div onclick="showMainMenu()">‚ùå Close Session</div>
                            </div>
                        </div>
                        <input type="file" id="inpFile" accept="image/*" style="display:none">
                        <input type="file" id="inpProject" accept=".json" multiple style="display:none">
                    </div>

                    <div class="header-center" id="headerTitle">
                        Project_Results
                    </div>

                    <div class="header-right">
                        <button class="btn btn-excel" onclick="openStatsModal()">üìä Stats</button>
                        <div class="dropdown">
                            <button class="btn btn-blue" onclick="toggleDropdown('exportDropdown')">‚¨á Export ‚ñæ</button>
                            <div id="exportDropdown" class="dropdown-content">
                                <div onclick="exportExcel('COUNTS')">üî¢ Excel (Counts)</div>
                                <div onclick="exportExcel('STATS')">üìä Excel (Stats)</div>
                                <div onclick="exportExcel('FULL')">üìë Excel (Complete)</div>
                                <div style="border-top:1px solid #444; margin-top:5px"></div>
                                <div onclick="downloadImg()">üñºÔ∏è Image (JPG)</div>
                                <div onclick="downloadImgWithCounts()">üì∏ Image + Overlay</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- ROW 2: TOOLS (Centered) -->
                <div class="tools-container">
                    <button class="btn btn-calib" onclick="openCalibration()">üìê Calib</button>
                    <div style="width:1px; height:20px; background:var(--border); margin:0 5px;"></div>

                    <div id="zoomContainer" style="background:none; border:none; padding:0;">
                        <button class="btn btn-zoom" onclick="changeZoom(-10)">-</button>
                        <input type="range" id="zoomSlider" min="10" max="400" value="100"
                            oninput="updateZoom(this.value)">
                        <button class="btn btn-zoom" onclick="changeZoom(10)">+</button>
                        <span id="zoomLabel" style="font-size:11px; width:35px; text-align:right;">100%</span>
                        <button class="btn" style="padding:4px 8px; font-size:11px;"
                            onclick="fitToScreen()">Fit</button>
                    </div>

                    <div style="width:1px; height:20px; background:var(--border); margin:0 5px;"></div>
                    <button id="btnPan" class="btn active" onclick="setMode('pan')">‚úã Pan</button>
                    <button id="btnSelect" class="btn" onclick="setMode('select')">üëÜ Edit</button>
                    <div style="width:1px; height:20px; background:var(--border); margin:0 5px;"></div>
                    <button id="btnDoubtMode" class="btn btn-doubt-mode" onclick="toggleDoubtMode()">‚ö†Ô∏è Doubt</button>
                </div>

                <!-- ROW 3: DRAWING TOOLS (Untouched) -->
                <div class="row" id="toolsRow" style="padding:8px;">
                    <button id="toolLineFs" class="btn active" onclick="setDrawTool('line_fs')"
                        style="border-left:5px solid #ff3b30">üìè Scratches</button>
                    <button id="toolSp" class="btn" onclick="setDrawTool('point_sp')"
                        style="border-left:5px solid #007aff">üîµ Sp</button>
                    <button id="toolPp" class="btn" onclick="setDrawTool('point_pp')"
                        style="border-left:5px solid #ff9500">üü† Pp</button>
                    <button id="toolCircle" class="btn" onclick="setDrawTool('circle_auto')"
                        style="border-left:5px solid #555">‚≠ï Auto</button>
                    <div style="width:1px; height:20px; background:var(--border); margin:0 5px;"></div>
                    <button id="btnMarkDoubt" class="btn btn-mark-doubt" onclick="markSelectedAsDoubt()"
                        style="display:none;">‚ùì Mark</button>
                    <button id="btnDelete" class="btn btn-red" onclick="deleteSelected()" style="display:none;">üóëÔ∏è
                        Del</button>
                    <button class="btn" onclick="undo()" id="btnUndo">‚Ü© Undo</button>
                    <button class="btn" onclick="redo()" id="btnRedo">‚Ü™ Redo</button>
                </div>
            </div>

            <div id="stats-bar">Load photo to start.</div>

            <div id="viewport" class="mode-pan">
                <div id="doubtOverlayMsg">‚ö†Ô∏è DOUBT MODE: Drag to measure (Perpendicular)</div>
                <div id="noImageMsg" onclick="document.getElementById('inpFile').click()">
                    üñºÔ∏è No Image Loaded<br>Click here to select photo for<br><span id="msgSampleName">this sample</span>
                </div>
                <canvas id="cvs" style="display:none;"></canvas>
            </div>
        </div>
    </div>

    <div id="modalOverlay">
        <div id="modalBox">
            <h3>Calibration</h3>
            <div class="modal-section">
                <h4>Method 1: FOV</h4>
                <input type="number" id="fovInput" class="inp-num" placeholder="Ex. 500">
                <select id="fovUnit" class="inp-sel">
                    <option value="¬µm">¬µm</option>
                    <option value="mm">mm</option>
                </select>
                <br><br><button class="btn btn-blue" onclick="applyFOV()">Apply</button>
            </div>
            <div class="modal-section" style="border-bottom:none;">
                <h4>Method 2: Manual</h4>
                <button class="btn" onclick="startMeasureRef()">üìç Pick 2 points</button>
                <br><br>
                <div id="manualInputArea" style="opacity:0.5; pointer-events:none;">
                    <span id="pixelReadout" style="font-size:11px; font-weight:bold;">px: 0</span><br>
                    <input type="number" id="manInput" class="inp-num" placeholder="Dist.">
                    <select id="manUnit" class="inp-sel">
                        <option value="¬µm">¬µm</option>
                        <option value="mm">mm</option>
                    </select>
                    <br><br><button class="btn btn-blue" onclick="applyManual()">Apply Manual</button>
                </div>
            </div>
            <button class="btn btn-red" onclick="closeModal()" style="width:100%">Close</button>
        </div>
    </div>

    <!-- Batch Import Modal -->
    <div id="importModal"
        style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.6); z-index:4000; justify-content:center; align-items:center;">
        <div
            style="background:var(--modal-bg); color:var(--text-main); padding:20px; border-radius:12px; width:95%; max-width:500px; display:flex; flex-direction:column; max-height:80vh;">
            <h3 style="margin-top:0; border-bottom:1px solid var(--border); padding-bottom:10px;">Batch Import (Staging)
            </h3>
            <div style="margin-bottom:15px; display:flex; flex-direction:column; gap:10px;">
                <p style="font-size:13px; color:var(--text-sec); margin:0;">Select JSON files from any folder. They will
                    queue here.</p>
                <button class="btn btn-blue" style="justify-content:center;"
                    onclick="document.getElementById('inpBatchJSON').click()">üìÇ Browse Files...</button>
                <input type="file" id="inpBatchJSON" accept=".json" multiple style="display:none"
                    onchange="handleBatchSelect(this)">
            </div>

            <div
                style="flex-grow:1; overflow-y:auto; border:1px solid var(--border); border-radius:6px; margin-bottom:15px; background:var(--bg-sidebar);">
                <ul id="stagedFilesList" style="list-style:none; padding:0; margin:0;">
                    <!-- Staged items go here -->
                </ul>
            </div>

            <div style="display:flex; justify-content:space-between; gap:10px;">
                <button class="btn" onclick="closeImportModal()">Cancel</button>
                <button class="btn btn-green" id="btnImportAll" onclick="importAllStaged()" disabled>‚úÖ Import
                    All</button>
            </div>
        </div>
    </div>

    <!-- Group Selection Modal -->
    <div id="groupSelectionModal"
        style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.6); z-index:4500; justify-content:center; align-items:center;">
        <div
            style="background:var(--modal-bg); color:var(--text-main); padding:24px; border-radius:16px; width:90%; max-width:320px; box-shadow:0 15px 40px rgba(0,0,0,0.4);">
            <h3 style="margin-top:0; margin-bottom:20px; text-align:center;">New Sample</h3>

            <div style="margin-bottom:15px; text-align:left;">
                <label
                    style="display:block; font-size:11px; font-weight:bold; color:var(--text-sec); margin-bottom:4px; text-transform:uppercase;">Sample
                    Name</label>
                <input type="text" id="newSampleNameInput" class="inp-text-wide" placeholder="Sample Name">
            </div>

            <div style="margin-bottom:25px; text-align:left;">
                <label
                    style="display:block; font-size:11px; font-weight:bold; color:var(--text-sec); margin-bottom:4px; text-transform:uppercase;">Assign
                    to Group</label>
                <select id="groupSelectDropdown" class="inp-sel-wide" onchange="handleGroupSelectChange()">
                    <!-- Options populated by JS -->
                </select>
                <input type="text" id="newGroupNameInput" class="inp-text-wide" style="display:none; margin-top:8px;"
                    placeholder="New Group Name">
            </div>

            <div style="display:flex; justify-content:flex-end; gap:10px;">
                <button class="btn" onclick="closeGroupModal()">Cancel</button>
                <button class="btn btn-blue" onclick="confirmCreateSample()"
                    style="flex-grow:1; justify-content:center;">Create</button>
            </div>
        </div>
    </div>

    <!-- Generic Custom Dialog -->
    <div id="dialogOverlay"
        style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.6); z-index:5000; justify-content:center; align-items:center;">
        <div id="dialogBox"
            style="background:var(--modal-bg); color:var(--text-main); padding:24px; border-radius:16px; width:90%; max-width:400px; box-shadow:0 15px 40px rgba(0,0,0,0.4); display:flex; flex-direction:column; gap:16px; text-align:center;">
            <h3 id="dialogTitle" style="margin:0; font-size:20px;">Title</h3>
            <div id="dialogMessage" style="font-size:15px; line-height:1.5; color:var(--text-sec);">Message content
                here.</div>
            <div id="dialogContent" style="width:100%;"></div> <!-- Container for custom inputs if needed -->
            <div id="dialogButtons" style="display:flex; flex-direction:column; gap:8px; margin-top:10px;">
                <!-- Buttons injected here -->
            </div>
        </div>
    </div>

    <!-- Advanced Stats & Export Modal -->
    <div id="statsModalOverlay"
        style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); z-index:2100; justify-content:center; align-items:center;">
        <div
            style="background:var(--modal-bg); color:var(--text-main); padding:20px; border-radius:12px; width:95%; max-width:400px; max-height:90%; overflow-y:auto; box-shadow:0 10px 25px rgba(0,0,0,0.3); display:flex; flex-direction:column;">
            <h3 style="margin-top:0; border-bottom:1px solid var(--border); padding-bottom:10px;">Advanced Statistics
            </h3>
            <div id="statsContent"
                style="font-size:13px; line-height:1.6; flex-grow:1; overflow-y:auto; margin-bottom:15px;"></div>

            <h4 style="margin:10px 0 10px 0; border-top:1px solid var(--border); padding-top:10px;">Export Data</h4>
            <div style="display:flex; flex-direction:column; gap:8px;">
                <button class="btn btn-blue" style="justify-content:center; padding:10px;"
                    onclick="exportExcel('COUNTS')">1. Counts Only</button>
                <button class="btn btn-purple" style="justify-content:center; padding:10px;"
                    onclick="exportExcel('STATS')">2. Adv. Stats Only</button>
                <button class="btn btn-green" style="justify-content:center; padding:10px;"
                    onclick="exportExcel('FULL')">3. Complete (All)</button>
            </div>
            <br>
            <button class="btn btn-red" onclick="document.getElementById('statsModalOverlay').style.display='none'"
                style="width:100%">Close</button>
        </div>
    </div>

    <script>
        // ==========================================================================
        // INITIALIZATION & SERVICE WORKER
        // ==========================================================================
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js');
        }

        // ==========================================================================
        // GLOBAL CONSTANTS & CONFIGURATION
        // ==========================================================================

        // Category definitions for annotations
        const CATS = {
            'sp': { label: 'Sp', color: '#007aff' },   // Small Pits
            'lp': { label: 'Lp', color: '#af52de' },   // Large Pits
            'g': { label: 'G', color: '#000000' },   // Granules/Other
            'pp': { label: 'Pp', color: '#ff9500' },   // Puncture Pits
            'fs': { label: 'Fs', color: '#ff3b30' },   // Fine Scratches
            'cs': { label: 'Cs', color: '#ffcc00' },   // Coarse Scratches
            'hcs': { label: 'HCs', color: '#34c759' }  // Hyper-Coarse Scratches
        };

        // Order in which statistics should be calculated/displayed
        const STATS_ORDER = ['sp', 'lp', 'pp', 'fs', 'cs', 'hcs', 'g'];

        // DOM Element References
        const cvs = document.getElementById('cvs');
        const ctx = cvs.getContext('2d');
        const viewport = document.getElementById('viewport');
        const statsBar = document.getElementById('stats-bar');
        const zoomSlider = document.getElementById('zoomSlider');
        const sampleListEl = document.getElementById('sampleList');
        const projNameEl = document.getElementById('projNameDisplay');
        const toolsRow = document.getElementById('toolsRow');

        // ==========================================================================
        // APP STATE VARIABLES
        // ==========================================================================

        // Data State
        let projectSamples = [];
        let activeSampleId = null;
        let currentProjectName = "Project_Results";
        let items = [];         // Current annotation items for the active sample
        let redoStack = [];     // History for redo operations
        let currentFileName = "sample";

        // UI/Canvas State
        let img = new Image();
        let mode = 'pan';               // 'pan', 'draw', 'select', 'measure', 'doubt_measure'
        let activeDrawTool = 'line_fs'; // Current tool for drawing
        let currentScale = 1;           // Zoom level (1 = 100%)
        let isDoubtMode = false;        // Toggle for marking ambiguous features

        // Calibration State
        let pixelsPerUnit = 1;
        let unitName = "px";
        let isCalibrated = false;

        // Interaction State
        let isDragging = false;
        let startPos = { x: 0, y: 0 };
        let panStart = { x: 0, y: 0 };
        let selectedItem = null;
        let dragItemStart = null;
        let measurePoints = [];
        let perpEndPos = { x: 0, y: 0 };

        // ==========================================================================
        // UI INTERACTION: DROPDOWNS & MENUS
        // ==========================================================================

        /**
         * Toggles the visibility of a dropdown menu.
         * @param {string} id - The ID of the dropdown content element.
    */
        function toggleDropdown(id) {
            document.getElementById(id).classList.toggle("show");
        }

        // Close dropdowns if clicking outside
        window.onclick = function (event) {
            if (!event.target.matches('.btn') && !event.target.matches('.btn *')) {
                var dropdowns = document.getElementsByClassName("dropdown-content");
                for (var i = 0; i < dropdowns.length; i++) {
                    var openDropdown = dropdowns[i];
                    if (openDropdown.classList.contains('show')) {
                        openDropdown.classList.remove('show');
                    }
                }
            }
        }

        function startApp() {
            document.getElementById('mainMenu').classList.add('hidden');
        }

        function showMainMenu() {
            document.getElementById('mainMenu').classList.remove('hidden');
        }

        function triggerLoadProject() {
            document.getElementById('inpProject').click();
        }

        function toggleSettings() {
            const p = document.getElementById('settingsPanel');
            p.style.display = p.style.display === 'flex' ? 'none' : 'flex';
        }

        // ==========================================================================
        // THEME MANAGEMENT
        // ==========================================================================

        function setTheme(mode) {
            localStorage.setItem('hyaena_theme', mode);
            applyTheme(mode);
            updateThemeUI(mode);
        }

        function applyTheme(mode) {
            const root = document.documentElement;
            if (mode === 'auto') {
                const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                root.setAttribute('data-theme', prefersDark ? 'dark' : 'light');
            } else {
                root.setAttribute('data-theme', mode);
            }
        }

        function updateThemeUI(mode) {
            ['themeLight', 'themeDark', 'themeAuto'].forEach(id => {
                document.getElementById(id).classList.remove('selected');
            });
            if (mode === 'light') document.getElementById('themeLight').classList.add('selected');
            else if (mode === 'dark') document.getElementById('themeDark').classList.add('selected');
            else document.getElementById('themeAuto').classList.add('selected');
        }

        // Load saved theme on startup
        const savedTheme = localStorage.getItem('hyaena_theme') || 'auto';
        setTheme(savedTheme);


        // ==========================================================================
        // STATE SYNCHRONIZATION
        // ==========================================================================

        /**
         * Syncs the current working state (items, calibration) back to the projectSamples array
         * and updates the UI stats for the active sample.
         */
        function syncState() {
            if (!activeSampleId) return;
            const idx = projectSamples.findIndex(s => s.id === activeSampleId);
            if (idx !== -1) {
                // Save current items and calibration to the sample object
                projectSamples[idx].items = JSON.parse(JSON.stringify(items));
                projectSamples[idx].calibration = {
                    ppu: pixelsPerUnit,
                    unit: unitName,
                    calibrated: isCalibrated
                };

                // Update the stats displayed in the sidebar list
                const li = sampleListEl.children[idx];
                if (li) {
                    let counts = {};
                    STATS_ORDER.forEach(k => counts[k] = 0);
                    items.forEach(it => {
                        if (counts[it.catId] !== undefined) counts[it.catId]++
                    });

                    let statParts = [];
                    STATS_ORDER.forEach(k => {
                        if (counts[k] > 0) statParts.push(`${CATS[k].label}:${counts[k]}`);
                    });

                    let statStr = statParts.length > 0 ? statParts.join(" | ") : "No data (0)";
                    const statsDiv = li.querySelector('.sample-stats');
                    if (statsDiv) statsDiv.innerText = statStr;
                }
            }
        }

        // ==========================================================================
        // PROJECT & SAMPLE MANAGEMENT (CRUD)
        // ==========================================================================

        function initNewSample(name, groupName) {
            return {
                id: Date.now().toString() + Math.random().toString().substr(2, 5),
                name: name,
                group: groupName || currentProjectName,
                items: [],
                calibration: { ppu: 1, unit: 'px', calibrated: false },
            };
        }

        function createNewSample(askName = true) {
            syncState();

            if (askName) {
                openGroupModal();
            } else {
                // Legacy/Automated fallback
                let name = "Sample_" + (projectSamples.length + 1);
                const newSample = initNewSample(name, currentProjectName);
                projectSamples.push(newSample);
                loadSampleIntoView(newSample.id);
                renderSampleList();
            }
        }

        // --- GROUP SELECTION MODAL LOGIC ---

        function getExistingGroups() {
            // Get unique groups from projectSamples, plus the currentProjectName
            const groups = new Set();
            if (currentProjectName) groups.add(currentProjectName);

            projectSamples.forEach(s => {
                if (s.group) groups.add(s.group);
            });

            return Array.from(groups).sort();
        }

        function openGroupModal() {
            const modal = document.getElementById('groupSelectionModal');
            const nameInput = document.getElementById('newSampleNameInput');
            const groupSelect = document.getElementById('groupSelectDropdown');
            const groupInput = document.getElementById('newGroupNameInput');

            // Set default name
            nameInput.value = "Sample_" + (projectSamples.length + 1);

            // Populate groups
            groupSelect.innerHTML = '';
            const groups = getExistingGroups();

            // Add existing groups options
            groups.forEach(g => {
                const opt = document.createElement('option');
                opt.value = g;
                opt.innerText = g;
                groupSelect.appendChild(opt);
            });

            // Add "Create New" option
            const newOpt = document.createElement('option');
            newOpt.value = "__NEW_GROUP__";
            newOpt.innerText = "‚ûï Create New Group...";
            groupSelect.appendChild(newOpt);

            // Select current sample's group if possible, or the first available
            const currentActive = projectSamples.find(s => s.id === activeSampleId);
            if (currentActive && currentActive.group) {
                groupSelect.value = currentActive.group;
            } else if (groups.length > 0) {
                groupSelect.value = groups[0];
            }

            // Reset UI state
            handleGroupSelectChange();

            modal.style.display = 'flex';
            nameInput.select();
            nameInput.focus();
        }

        function closeGroupModal() {
            document.getElementById('groupSelectionModal').style.display = 'none';
        }

        function handleGroupSelectChange() {
            const val = document.getElementById('groupSelectDropdown').value;
            const inp = document.getElementById('newGroupNameInput');
            if (val === '__NEW_GROUP__') {
                inp.style.display = 'block';
                inp.focus();
            } else {
                inp.style.display = 'none';
            }
        }

        function confirmCreateSample() {
            const nameInput = document.getElementById('newSampleNameInput');
            const groupSelect = document.getElementById('groupSelectDropdown');
            const groupInput = document.getElementById('newGroupNameInput');

            const name = nameInput.value.trim() || ("Sample_" + (projectSamples.length + 1));
            let group = groupSelect.value;

            if (group === '__NEW_GROUP__') {
                group = groupInput.value.trim();
                if (!group) {
                    alert("Please enter a name for the new group.");
                    return;
                }
            }

            const newSample = initNewSample(name, group);
            projectSamples.push(newSample);
            loadSampleIntoView(newSample.id);
            renderSampleList();
            closeGroupModal();
        }

        function renameSample(id) {
            const sample = projectSamples.find(s => s.id === id);
            if (!sample) return;
            const newName = prompt("Rename sample:", sample.name);
            if (newName && newName !== sample.name) {
                sample.name = newName;
                if (activeSampleId === id) currentFileName = newName;
                renderSampleList();
            }
        }

        function deleteSample(id) {
            if (!confirm("Are you sure you want to delete this sample?")) return;
            const index = projectSamples.findIndex(s => s.id === id);
            if (index === -1) return;

            projectSamples.splice(index, 1);

            // If dragging executed deletion, determine what to show next
            if (projectSamples.length === 0) {
                createNewSample(false);
            } else if (activeSampleId === id) {
                loadSampleIntoView(projectSamples[Math.max(0, index - 1)].id);
            }
            renderSampleList();
        }

        function sortSamplesAZ() {
            syncState();
            projectSamples.sort((a, b) => {
                // Primary sort by Group
                const gA = (a.group || "").toLowerCase();
                const gB = (b.group || "").toLowerCase();
                if (gA < gB) return -1;
                if (gA > gB) return 1;

                // Secondary sort by Name
                const nA = a.name.toLowerCase();
                const nB = b.name.toLowerCase();
                if (nA < nB) return -1;
                if (nA > nB) return 1;
                return 0;
            });
            renderSampleList();
        }

        // DRAG AND DROP HANDLERS
        function handleDragStart(e) {
            dragSrcEl = this; // 'this' is the row being dragged
            dragSrcIndex = parseInt(this.getAttribute('data-index'));
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', this.innerHTML);
            this.classList.add('dragging');
        }

        function handleDragOver(e) {
            if (e.preventDefault) e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            return false;
        }

        function handleDragEnter(e) {
            this.classList.add('drag-over');
        }

        function handleDragLeave(e) {
            this.classList.remove('drag-over');
        }

        function handleDrop(e) {
            if (e.stopPropagation) e.stopPropagation();

            if (dragSrcEl !== this) {
                const targetIndex = parseInt(this.getAttribute('data-index'));

                // Reorder array
                // We use the stored global index to move items
                // Moving from dragSrcIndex to targetIndex
                const itemToMove = projectSamples[dragSrcIndex];

                // Remove from old position
                projectSamples.splice(dragSrcIndex, 1);
                // Insert at new position
                projectSamples.splice(targetIndex, 0, itemToMove);

                // Force redraw of list
                renderSampleList();

                // Sync state to keep changes
                syncState();
            }
            return false;
        }

        function handleDragEnd(e) {
            this.classList.remove('dragging');
            // Remove .drag-over from everyone
            const items = document.querySelectorAll('.sample-item');
            items.forEach(item => item.classList.remove('drag-over'));
        }

        function renameProject() {
            const newName = prompt("Rename Project:", currentProjectName);
            if (newName) {
                currentProjectName = newName;
                projNameEl.innerText = currentProjectName;
            }
        }

        /**
         * Loads a specific sample by ID into the workspace.
         */
        function loadSampleIntoView(id) {
            syncState(); // Save previous work first
            activeSampleId = id;

            const sample = projectSamples.find(s => s.id === id);
            if (!sample) return;

            // Restore state from sample
            items = JSON.parse(JSON.stringify(sample.items));
            resetHistory();
            currentFileName = sample.name;

            if (sample.calibration) {
                pixelsPerUnit = sample.calibration.ppu;
                unitName = sample.calibration.unit;
                isCalibrated = sample.calibration.calibrated;
            } else {
                pixelsPerUnit = 1;
                unitName = "px";
                isCalibrated = false;
            }

            // Reset image and load if available
            // Note: In this simple local scaffolding, we don't persist image blobs deeply
            // unless we had a proper backend or indexedDB. 
            // The user must re-load the image if it's a fresh session, 
            // OR we assume the image context is kept if just switching in memory.
            // For now, we just reset the canvas area until an image is provided.

            // If the sample was just imported with imageSrc (base64) from JSON:
            if (sample.imageSrc) {
                // To be implemented fully if we want to store base64 images (heavy)
                // For now, checks are done in the UI.
            }

            // Reset UI for new sample
            img = new Image(); // Clear current image reference
            cvs.style.display = 'none';
            document.getElementById('noImageMsg').style.display = 'block';
            document.getElementById('msgSampleName').innerText = sample.name;
            statsBar.innerText = "Load photo to start.";

            renderSampleList();
            redraw();
        }

        // ==========================================================================
        // SIDEBAR & LIST RENDERING
        // ==========================================================================

        // Placeholder for future Drag & Drop logic (currently disabled/removed)
        let dragSrcEl = null;
        let dragSrcIndex = -1;

        function renderSampleList() {
            sampleListEl.innerHTML = '';
            let lastGroup = null;

            projectSamples.forEach((s, idx) => {
                // Ensure group exists
                if (!s.group) s.group = currentProjectName;

                // Insert Header if group changes (Grouping Logic)
                if (s.group !== lastGroup) {
                    const h = document.createElement('li');
                    h.className = 'list-header';
                    h.innerText = s.group;
                    sampleListEl.appendChild(h);
                    lastGroup = s.group;
                }

                const li = document.createElement('li');
                li.className = 'sample-item ' + (s.id === activeSampleId ? 'active' : '');

                li.onclick = () => loadSampleIntoView(s.id);

                // Calculate mini-stats for the list item
                let counts = {};
                STATS_ORDER.forEach(k => counts[k] = 0);
                s.items.forEach(it => {
                    if (counts[it.catId] !== undefined) counts[it.catId]++
                });

                let statParts = [];
                STATS_ORDER.forEach(k => {
                    if (counts[k] > 0) statParts.push(`${CATS[k].label}:${counts[k]}`);
                });

                let statStr = statParts.length > 0 ? statParts.join(" | ") : "No data (0)";

                li.draggable = true;
                li.setAttribute('data-index', idx); // Creating a local data attribute for index

                // Add Drag & Drop Event Listeners
                li.addEventListener('dragstart', handleDragStart, false);
                li.addEventListener('dragenter', handleDragEnter, false);
                li.addEventListener('dragover', handleDragOver, false);
                li.addEventListener('dragleave', handleDragLeave, false);
                li.addEventListener('drop', handleDrop, false);
                li.addEventListener('dragend', handleDragEnd, false);

                // Build HTML for the list item
                li.innerHTML = `
    <div class="sample-info">
        <div class="sample-name">${s.name}</div>
        <div class="sample-stats">${statStr}</div>
        <div class="sample-warning ${activeSampleId === s.id && !img.src ? 'no-img' : ''}">‚ö†Ô∏è No Image</div>
    </div>
    <div class="btn-icon-group">
        <button class="btn-icon-small" onclick="event.stopPropagation(); renameSample('${s.id}')" title="Rename">‚úé</button>
        <button class="btn-icon-small danger" onclick="event.stopPropagation(); deleteSample('${s.id}')" title="Delete">üóëÔ∏è</button>
    </div>
    `;
                sampleListEl.appendChild(li);
            });
        }

        function toggleSidebar() {
            document.getElementById('sidebar').classList.remove('fullscreen');
            document.getElementById('sidebar').classList.toggle('collapsed');
        }

        function toggleSidebarFullscreen() {
            document.getElementById('sidebar').classList.remove('collapsed');
            document.getElementById('sidebar').classList.toggle('fullscreen');
        }

        // ==========================================================================
        // FILE I/O: SAVE & EXPORT
        // ==========================================================================

        function saveSingleSample() {
            if (!img.src) {
                alert("No image loaded!");
                return;
            }
            syncState();
            const d = {
                imageSrc: img.src, // WARNING: Base64 strings can be very large
                items: items,
                calibration: { ppu: pixelsPerUnit, unit: unitName, calibrated: isCalibrated },
                date: new Date().toISOString()
            };

            let name = prompt("Filename for this sample:", currentFileName);
            if (!name) return;

            const b = new Blob([JSON.stringify(d)], { type: "application/json" });
            const l = document.createElement('a');
            l.download = name + ".json";
            l.href = URL.createObjectURL(b);
            l.click();
        }

        function saveProject() {
            syncState();
            if (projectSamples.length === 0) {
                alert("Project is empty.");
                return;
            }
            const projectData = {
                type: "hyaena_project",
                version: 1,
                name: currentProjectName,
                date: new Date().toISOString(),
                samples: projectSamples
            };
            const b = new Blob([JSON.stringify(projectData)], { type: "application/json" });
            const l = document.createElement('a');
            l.download = currentProjectName + ".json";
            l.href = URL.createObjectURL(b);
            l.click();
        }

        // ==========================================================================
        // BATCH IMPORT LOGIC
        // ==========================================================================
        let stagedFiles = [];

        function openImportModal() {
            stagedFiles = [];
            renderStagedList();
            document.getElementById('importModal').style.display = 'flex';
            // Hide Menu if open
            if (document.getElementById('menuDropdown').classList.contains('show')) toggleDropdown('menuDropdown');
        }

        function closeImportModal() {
            document.getElementById('importModal').style.display = 'none';
            stagedFiles = [];
        }

        function handleBatchSelect(input) {
            const files = Array.from(input.files);
            if (files.length === 0) return;

            files.forEach(f => {
                // simple duplicate check by name
                if (!stagedFiles.some(sf => sf.name === f.name)) {
                    stagedFiles.push(f);
                }
            });

            renderStagedList();
            input.value = ''; // allow re-selecting same folder/files if needed
        }

        function renderStagedList() {
            const listEl = document.getElementById('stagedFilesList');
            const btnImport = document.getElementById('btnImportAll');
            listEl.innerHTML = '';

            if (stagedFiles.length === 0) {
                listEl.innerHTML = `<li style="padding:15px; text-align:center; color:var(--text-sec); font-style:italic;">No files selected</li>`;
                btnImport.disabled = true;
                return;
            }

            btnImport.disabled = false;
            stagedFiles.forEach((f, idx) => {
                const li = document.createElement('li');
                li.style.cssText = "padding:8px 12px; border-bottom:1px solid var(--border); display:flex; justify-content:space-between; align-items:center; color:var(--text-main); font-size:13px;";

                const nameSpan = document.createElement('span');
                nameSpan.innerText = f.name;

                const delBtn = document.createElement('button');
                delBtn.innerText = "‚úï";
                delBtn.className = "btn-icon-small danger";
                delBtn.style.marginLeft = "10px";
                delBtn.onclick = () => {
                    stagedFiles.splice(idx, 1);
                    renderStagedList();
                };

                li.appendChild(nameSpan);
                li.appendChild(delBtn);
                listEl.appendChild(li);
            });
        }

        async function importAllStaged() {
            if (stagedFiles.length === 0) return;

            document.getElementById('importModal').style.display = 'none';

            // 1. Read all files first
            const fileReads = stagedFiles.map(file => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = evt => {
                        try {
                            const data = JSON.parse(evt.target.result);
                            // Normalize to sample object
                            let s = null;
                            if (data.type === 'hyaena_project') {
                                // If user selected a project file by mistake in batch, take its samples
                                s = data.samples || [];
                            } else {
                                // Single sample
                                const name = file.name.replace('.json', '');
                                s = initNewSample(name);
                                s.items = data.items || [];
                                if (data.calibration) {
                                    s.calibration = { ppu: data.calibration.ppu, unit: data.calibration.unit, calibrated: true };
                                }
                            }
                            resolve(Array.isArray(s) ? s : [s]);
                        } catch (e) {
                            console.error("Error batch parsing", file.name, e);
                            resolve([]); // Skip bad files
                        }
                    };
                    reader.readAsText(file);
                });
            });

            // Wait for all to be read
            const results = await Promise.all(fileReads);
            // Flatten array of arrays
            const newSamples = results.flat();

            if (newSamples.length === 0) {
                alert("No valid samples imported.");
                return;
            }

            // Check for duplicates
            const duplicates = newSamples.filter(s => isDuplicateName(s.name));
            if (duplicates.length > 0) {
                const names = duplicates.map(d => d.name).join(", ");
                alert("Warning: The following samples already exist in the project:\n" + names + "\n\nCreating duplicates.");
            }

            // 2. Ask User for Group (Generic Dialog)
            const existingGroups = [...new Set(projectSamples.map(x => x.group || currentProjectName))];

            const buttons = existingGroups.map(g => ({
                label: `Add to <b>${g}</b>`,
                class: "btn-blue",
                onClick: () => {
                    finalizeBatchImport(newSamples, g);
                }
            }));

            buttons.push({
                label: `Create <b>New Group</b>`,
                class: "btn-green",
                onClick: () => {
                    const newG = prompt("Enter Name for New Group/Species:", "New_Species");
                    if (newG) finalizeBatchImport(newSamples, newG);
                }
            });

            buttons.push({
                label: `Start <b>New Session</b>`,
                class: "btn-red",
                onClick: () => {
                    if (confirm("This will clear the current project. Continue?")) {
                        // Reset Project and start fresh
                        currentProjectName = "New_Project";
                        document.getElementById('headerTitle').innerText = currentProjectName;
                        projectSamples = [];
                        const newG = prompt("Enter Name for Group/Species:", "Species_1");
                        finalizeBatchImport(newSamples, newG || "Species_1");
                    }
                }
            });
            buttons.push({ label: "Cancel", class: "", onClick: () => { } });

            showCustomDialog(
                "Batch Import",
                `Ready to import <b>${newSamples.length}</b> samples.<br>Select target Group:`,
                buttons
            );
        }

        function finalizeBatchImport(samples, groupName) {
            samples.forEach(s => {
                s.group = groupName;
                addSampleToProject(s);
            });
            renderSampleList();
            stagedFiles = []; // Clear buffer only after success
        }

        // ==========================================================================
        // CUSTOM DIALOG & MODAL UTILITIES
        // ==========================================================================

        function showCustomDialog(title, message, buttons, contentNode = null) {
            const overlay = document.getElementById('dialogOverlay');
            document.getElementById('dialogTitle').innerText = title;
            document.getElementById('dialogMessage').innerHTML = message;

            const btnContainer = document.getElementById('dialogButtons');
            btnContainer.innerHTML = '';

            const contentContainer = document.getElementById('dialogContent');
            contentContainer.innerHTML = '';
            if (contentNode) contentContainer.appendChild(contentNode);

            buttons.forEach(btn => {
                const b = document.createElement('button');
                b.className = `btn ${btn.class || ''}`;
                b.style.justifyContent = 'center';
                b.style.padding = '12px';
                b.innerHTML = btn.label;
                b.onclick = () => {
                    overlay.style.display = 'none';
                    if (btn.onClick) btn.onClick();
                };
                btnContainer.appendChild(b);
            });

            overlay.style.display = 'flex';
        }

        // ==========================================================================
        // SINGLE FILE IMPORT LOGIC
        // ==========================================================================

        function handleFileSelection(e) {
            const files = Array.from(e.target.files);
            if (files.length === 0) return;
            if (document.getElementById('mainMenu').style.display !== 'none') {
                startApp();
            }

            const file = files[0]; // Process first file only in this simplistic logic

            if (file.name.endsWith('.json')) {
                // JSON Import
                const reader = new FileReader();
                reader.onload = evt => {
                    try {
                        const data = JSON.parse(evt.target.result);
                        if (data.type === "hyaena_project") {
                            const newSamples = data.samples || [];
                            const newProjName = data.name || "Imported_Project";

                            // Tag imported samples
                            newSamples.forEach(s => { if (!s.group) s.group = newProjName; });

                            if (projectSamples.length === 0) {
                                // Direct load if empty
                                projectSamples = newSamples;
                                currentProjectName = newProjName;
                                document.getElementById('headerTitle').innerText = currentProjectName;
                                loadSampleIntoView(projectSamples[0].id);
                            } else {
                                // CUSTOM DIALOG: MERGE vs REPLACE
                                showCustomDialog(
                                    "Import Project",
                                    `Ready to import "${newProjName}" (${newSamples.length} samples).`,
                                    [
                                        {
                                            label: "<b>MERGE (Append)</b><br><span style='font-size:11px'>Add to current list as new group</span>",
                                            class: "btn-green",
                                            onClick: () => {
                                                projectSamples.forEach(s => { if (!s.group) s.group = currentProjectName; });
                                                projectSamples = projectSamples.concat(newSamples);
                                                renderSampleList();
                                            }
                                        },
                                        {
                                            label: "<b>REPLACE</b><br><span style='font-size:11px'>Discard current and load new</span>",
                                            class: "btn-red",
                                            onClick: () => {
                                                projectSamples = newSamples;
                                                currentProjectName = newProjName;
                                                document.getElementById('headerTitle').innerText = currentProjectName;
                                                loadSampleIntoView(projectSamples[0].id);
                                            }
                                        },
                                        { label: "Cancel", class: "", onClick: () => { } }
                                    ]
                                );
                            }
                        } else {
                            // Single Sample JSON Import
                            processSingleImport(file.name.replace('.json', ''), data);
                        }
                    } catch (err) { console.error("Error", err); alert("Invalid JSON"); }
                };
                reader.readAsText(file);
            } else if (file.type.startsWith('image/')) {
                // Image Load -> Single Sample Creation
                const fname = file.name.replace(/\.[^/.]+$/, "");
                const currSample = projectSamples.find(s => s.id === activeSampleId);
                const waitingForImage = activeSampleId && (cvs.style.display === 'none');

                if (waitingForImage) {
                    // Just load image into active sample
                    if (currSample && currSample.name.startsWith("Sample_")) {
                        currSample.name = fname;
                        currentFileName = fname;
                    }
                    renderSampleList();
                    loadImageFromFile(file);
                } else {
                    // Create NEW sample from image -> Ask for Group
                    if (isDuplicateName(fname)) {
                        alert(`Warning: The sample "${fname}" already exists.`);
                    }
                    const newSample = initNewSample(fname);

                    // Prepare Group Selection
                    const existingGroups = [...new Set(projectSamples.map(s => s.group || currentProjectName))];
                    const buttons = existingGroups.map(g => ({
                        label: `Add to <b>${g}</b>`,
                        class: "btn-blue",
                        onClick: () => {
                            newSample.group = g;
                            finalizeSingleImport(newSample, file);
                        }
                    }));

                    buttons.push({
                        label: `Create <b>New Group</b>`,
                        class: "btn-green",
                        onClick: () => {
                            const newG = prompt("Enter Name for New Group/Species:", "New_Species");
                            if (newG) {
                                newSample.group = newG;
                                finalizeSingleImport(newSample, file);
                            }
                        }
                    });
                    buttons.push({
                        label: `Start <b>New Session</b>`,
                        class: "btn-red",
                        onClick: () => {
                            if (confirm("This will clear the current project. Continue?")) {
                                currentProjectName = "New_Project";
                                document.getElementById('headerTitle').innerText = currentProjectName;
                                projectSamples = [];
                                const newG = prompt("Enter Name for Group/Species:", "Species_1");
                                newSample.group = newG || "Species_1";
                                finalizeSingleImport(newSample, file);
                            }
                        }
                    });
                    buttons.push({ label: "Cancel", class: "", onClick: () => { } });

                    showCustomDialog(
                        "New Sample",
                        `Where should "${fname}" be added?`,
                        buttons
                    );
                }
            }
            e.target.value = ''; // Reset input
        }

        function addSampleToProject(sample) {
            // Find insertion point: last item of the same group
            let insertIdx = -1;
            for (let i = projectSamples.length - 1; i >= 0; i--) {
                if (projectSamples[i].group === sample.group) {
                    insertIdx = i;
                    break;
                }
            }

            if (insertIdx !== -1) {
                // Insert after the last item of the group
                projectSamples.splice(insertIdx + 1, 0, sample);
            } else {
                // New group or empty list, append to end
                projectSamples.push(sample);
            }
        }

        function isDuplicateName(name) {
            return projectSamples.some(s => s.name === name);
        }

        function processSingleImport(name, data) {
            if (isDuplicateName(name)) {
                alert(`Warning: The sample "${name}" already exists in the current project.`);
            }

            // Ask for group for single JSON too
            const newSample = initNewSample(name);
            newSample.items = data.items || [];
            if (data.calibration) {
                newSample.calibration = { ppu: data.calibration.ppu, unit: data.calibration.unit, calibrated: true };
            }

            const existingGroups = [...new Set(projectSamples.map(s => s.group || currentProjectName))];
            const buttons = existingGroups.map(g => ({
                label: `Add to <b>${g}</b>`,
                class: "btn-blue",
                onClick: () => {
                    newSample.group = g;
                    addSampleToProject(newSample);
                    renderSampleList();
                }
            }));
            buttons.push({
                label: `Create <b>New Group</b>`,
                class: "btn-green",
                onClick: () => {
                    const newG = prompt("Enter Name for New Group/Species:", "New_Species");
                    if (newG) {
                        newSample.group = newG;
                        addSampleToProject(newSample);
                        renderSampleList();
                    }
                }
            });
            buttons.push({
                label: `Start <b>New Session</b>`,
                class: "btn-red",
                onClick: () => {
                    if (confirm("This will clear the current project. Continue?")) {
                        currentProjectName = "New_Project";
                        document.getElementById('headerTitle').innerText = currentProjectName;
                        projectSamples = [];
                        const newG = prompt("Enter Name for Group/Species:", "Species_1");
                        newSample.group = newG || "Species_1";
                        addSampleToProject(newSample);
                        renderSampleList();
                    }
                }
            });
            buttons.push({ label: "Cancel", class: "", onClick: () => { } });

            showCustomDialog("Import Sample", `Import "${name}" to which group?`, buttons);
        }

        function finalizeSingleImport(sample, imgFile) {
            addSampleToProject(sample);
            activeSampleId = sample.id;
            syncState();
            items = []; // Clear current items for new sample
            redoStack = [];
            isCalibrated = false;
            loadImageFromFile(imgFile);
        }

        function loadImageFromFile(file) {
            const r = new FileReader();
            r.onload = evt => {
                img = new Image();
                img.onload = () => {
                    cvs.style.display = 'block';
                    cvs.width = img.width;
                    cvs.height = img.height;
                    document.getElementById('noImageMsg').style.display = 'none';
                    fitToScreen();
                    renderSampleList();
                    redraw();
                };
                img.src = evt.target.result;
            };
            r.readAsDataURL(file);
        }

        document.getElementById('inpFile').addEventListener('change', handleFileSelection);
        document.getElementById('inpProject').addEventListener('change', handleFileSelection);
        // ==========================================================================
        // STATISTICS CALCULATION
        // ==========================================================================

        function getStatsFromItems(itemsList, calib) {
            const res = {
                crushingIndex: 0,
                percLargePits: 0,
                anisotropy: 0,
                meanOrient: 0,
                mechIndex: 0,
                bgAbrasion: 0,
                severity: 0,
                psRatio: 0,
                pitHet: 0,
                scratchHet: 0,
                globalHet: 0
            };

            if (!itemsList || itemsList.length === 0) return res;

            const isCal = calib ? calib.calibrated : false;
            const ppu = (calib && calib.ppu) ? calib.ppu : 1;

            // Dimensions for density/heterogeneity
            let wPx = (img && img.width) ? img.width : 0;
            let hPx = (img && img.height) ? img.height : 0;

            if ((!wPx || !hPx) && itemsList.length > 0) {
                // Fallback estimation based on item extent
                let maxX = 0, maxY = 0;
                itemsList.forEach(i => {
                    const x = i.type === 'line' ? Math.max(i.x1, i.x2) : i.x;
                    const y = i.type === 'line' ? Math.max(i.y1, i.y2) : i.y;
                    if (x > maxX) maxX = x;
                    if (y > maxY) maxY = y;
                });
                wPx = Math.max(1000, maxX * 1.1);
                hPx = Math.max(1000, maxY * 1.1);
            }
            if (wPx === 0) { wPx = 2000; hPx = 2000; } // Last resort default

            const STD_PIT_DIA = 2;
            const STD_SCR_W = 1.5;

            const pits = itemsList.filter(i => (i.type === 'point' || i.type === 'circle') && (i.catId === 'sp' || i.catId === 'lp'));
            const scratches = itemsList.filter(i => i.type === 'line');

            // 1. Pits Statistics
            let totalPitDia = 0;
            let largePits = 0;
            pits.forEach(p => {
                let d = 0;
                if (p.type === 'point') d = STD_PIT_DIA;
                else d = p.r * 2;

                if (isCal) d = d / ppu;
                totalPitDia += d;
                if (d > 4) largePits++; // >4um is considered Large
            });
            res.crushingIndex = pits.length > 0 ? (totalPitDia / pits.length) : 0;
            res.percLargePits = pits.length > 0 ? (largePits / pits.length) * 100 : 0;

            // 2. Scratches (Anisotropy & Mech Index)
            let totalLen = 0;
            let vectorSumX = 0;
            let vectorSumY = 0;
            let totalScrArea = 0;

            scratches.forEach(s => {
                const dx = s.x2 - s.x1;
                const dy = s.y2 - s.y1;
                let len = Math.hypot(dx, dy);
                if (isCal) len = len / ppu;
                totalLen += len;

                // Anisotropy (Mean Vector Length)
                // Double angle for orientation (0-180)
                const angle = Math.atan2(dy, dx);
                const angle2 = 2 * angle;
                vectorSumX += Math.cos(angle2);
                vectorSumY += Math.sin(angle2);

                // Area for Mech Index (Length * Width)
                let w = STD_SCR_W;
                if (isCal) w = w / ppu;
                totalScrArea += len * w;
            });

            if (scratches.length > 0) {
                const R = Math.hypot(vectorSumX, vectorSumY) / scratches.length;
                res.anisotropy = R; // 0 to 1
                const meanAng2 = Math.atan2(vectorSumY, vectorSumX);
                let meanAng = meanAng2 / 2;
                meanAng = meanAng * (180 / Math.PI); // Convert to Degrees
                if (meanAng < 0) meanAng += 180;
                res.meanOrient = meanAng;
            }

            // Mech Index: Scratches / Pits
            if (pits.length > 0) res.mechIndex = scratches.length / pits.length;
            else res.mechIndex = scratches.length;

            // 3. Impact / Abrasion
            const areaMm2 = (wPx * hPx) / (ppu * ppu) / 1000000; // px2 -> um2 -> mm2
            if (areaMm2 > 0) {
                // Background Abrasion: Total Scratch Length (mm) / Area (mm2)
                const lenMm = totalLen / 1000;
                res.bgAbrasion = lenMm / areaMm2;
            }

            // Severity: Total Scratch Area + Total Pit Area
            let totalPitArea = 0;
            pits.forEach(p => {
                let r = 0;
                if (p.type === 'point') r = STD_PIT_DIA / 2; else r = p.r;
                if (isCal) r = r / ppu;
                totalPitArea += Math.PI * r * r;
            });
            res.severity = totalScrArea + totalPitArea; // um2

            // P/S Ratio (Area)
            if (totalScrArea > 0) res.psRatio = totalPitArea / totalScrArea;

            // 4. Heterogeneity (Grid 10x10)
            const cw = wPx / 10;
            const ch = hPx / 10;
            const gridP = Array(10).fill(0).map(() => Array(10).fill(0));
            const gridS = Array(10).fill(0).map(() => Array(10).fill(0));

            pits.forEach(p => {
                const x = Math.floor(p.x / cw);
                const y = Math.floor(p.y / ch);
                if (x >= 0 && x < 10 && y >= 0 && y < 10) gridP[y][x]++;
            });

            scratches.forEach(s => {
                const cx = (s.x1 + s.x2) / 2;
                const cy = (s.y1 + s.y2) / 2;
                const x = Math.floor(cx / cw);
                const y = Math.floor(cy / ch);
                if (x >= 0 && x < 10 && y >= 0 && y < 10) gridS[y][x]++;
            });

            function getHet(grid) {
                let max = 0, sum = 0;
                for (let r = 0; r < 10; r++) {
                    for (let c = 0; c < 10; c++) {
                        const v = grid[r][c];
                        if (v > max) max = v;
                        sum += v;
                    }
                }
                const mean = sum / 100;
                return mean === 0 ? 0 : max / mean;
            }

            res.pitHet = getHet(gridP);
            res.scratchHet = getHet(gridS);

            // Global: Combo grid
            const gridG = Array(10).fill(0).map((_, r) => Array(10).fill(0).map((_, c) => gridP[r][c] + gridS[r][c]));
            res.globalHet = getHet(gridG);

            return res;
        }

        // ==========================================================================
        // STATS MODAL & EXPORT
        // ==========================================================================

        function openStatsModal() {
            syncState();
            const el = document.getElementById('statsModalOverlay');
            const content = document.getElementById('statsContent');

            if (!activeSampleId || !items || items.length === 0) {
                content.innerHTML = "No items in active sample.";
            } else {
                const s = projectSamples.find(x => x.id === activeSampleId);
                const st = getStatsFromItems(s.items, s.calibration);

                let h = `<table style="width:100%; border-collapse:collapse;">`;
                const row = (l, v) => `<tr><td style="border-bottom:1px solid #444; padding:4px;">${l}</td><td style="border-bottom:1px solid #444; padding:4px; font-weight:bold;">${v}</td></tr>`;

                h += row("Sample Name", s.name);
                h += row("Calibrated", s.calibration.calibrated ? "Yes" : "No");
                h += `<tr><td colspan="2" style="padding-top:10px; font-weight:bold; color:var(--accent);">Microwear Stats</td></tr>`;
                h += row("Crushing Index", st.crushingIndex.toFixed(2) + " ¬µm");
                h += row("% Large Pits", st.percLargePits.toFixed(1) + " %");
                h += row("Anisotropy (R)", st.anisotropy.toFixed(3));
                h += row("Mean Orientation", st.meanOrient.toFixed(1) + " ¬∞");
                h += row("Mech. Index (S/P)", st.mechIndex.toFixed(2));
                h += `<tr><td colspan="2" style="padding-top:10px; font-weight:bold; color:var(--accent);">Spatial / Impact</td></tr>`;
                h += row("Bg Abrasion", st.bgAbrasion.toFixed(4) + " mm/mm¬≤");
                h += row("Severity (Total Area)", st.severity.toFixed(0) + " ¬µm¬≤");
                h += row("P/S Area Ratio", st.psRatio.toFixed(3));
                h += row("Pit Heterogeneity", st.pitHet.toFixed(2));
                h += row("Scratch Heterogeneity", st.scratchHet.toFixed(2));
                h += row("Global Heterogeneity", st.globalHet.toFixed(2));
                h += `</table>`;
                content.innerHTML = h;
            }
            el.style.display = 'flex';
        }

        function exportExcel(mode) {
            document.getElementById('statsModalOverlay').style.display = 'none';
            if (projectSamples.length === 0) {
                alert("No data!");
                return;
            }

            const now = new Date();
            const dateStr = now.toISOString().split('T')[0];
            const safeName = currentProjectName.replace(/\s+/g, '_');
            const fname = `${safeName}_${mode}_${dateStr}.csv`;
            const sep = ";";
            let csv = "";

            // Headers
            let headers = ["Species", "Sample Name", "Calibrated"];
            if (mode === 'COUNTS' || mode === 'FULL') {
                STATS_ORDER.forEach(k => headers.push(CATS[k].label));
            }
            if (mode === 'STATS' || mode === 'FULL') {
                headers.push("Crushing Index (um)", "% Large Pits", "Anisotropy (R)", "Mean Orient (deg)", "Mech. Index", "Bg Abrasion (mm/mm2)", "Severity (um2)", "P/S Ratio", "Pit Het.", "Scratch Het.", "Global Het.");
            }
            csv += headers.join(sep) + "\n";

            projectSamples.forEach(s => {
                let row = [`"${s.group || currentProjectName}"`, `"${s.name}"`, s.calibration && s.calibration.calibrated ? 'Yes' : 'No'];

                if (mode === 'COUNTS' || mode === 'FULL') {
                    let counts = {};
                    STATS_ORDER.forEach(k => counts[k] = 0);
                    s.items.forEach(it => { if (counts[it.catId] !== undefined) counts[it.catId]++; });
                    STATS_ORDER.forEach(k => row.push(counts[k]));
                }

                if (mode === 'STATS' || mode === 'FULL') {
                    const st = getStatsFromItems(s.items, s.calibration);
                    row.push(
                        st.crushingIndex.toFixed(2), st.percLargePits.toFixed(1), st.anisotropy.toFixed(3), st.meanOrient.toFixed(1), st.mechIndex.toFixed(2),
                        st.bgAbrasion.toFixed(4), st.severity.toFixed(0), st.psRatio.toFixed(3), st.pitHet.toFixed(2), st.scratchHet.toFixed(2), st.globalHet.toFixed(2)
                    );
                }
                csv += row.join(sep) + "\n";
            });

            const l = document.createElement('a');
            l.href = 'data:text/csv;charset=utf-8,' + encodeURI(csv);
            l.download = fname;
            l.click();
        }

        // ==========================================================================
        // TOOLBAR & INTERACTION MODES
        // ==========================================================================

        function setMode(m) {
            mode = m;
            viewport.className = 'mode-' + m;

            ['btnPan', 'btnSelect'].forEach(id => document.getElementById(id).classList.remove('active'));

            if (m === 'pan') document.getElementById('btnPan').classList.add('active');
            if (m === 'select') document.getElementById('btnSelect').classList.add('active');

            if (m === 'draw') {
                updateToolVisuals();
            } else {
                document.querySelectorAll('#toolsRow .btn').forEach(b => {
                    if (!b.id.startsWith('btn')) b.classList.remove('active');
                });
            }

            // Restore/Dim toolbar based on mode ?? Maybe not needed, but code was here.
            toolsRow.style.opacity = '1';
            toolsRow.style.pointerEvents = 'auto';
            document.getElementById('btnMarkDoubt').style.display = 'none';
            document.getElementById('btnDelete').style.display = 'none';

            selectedItem = null;
            redraw();
        }

        function setDrawTool(toolName) {
            if (isDoubtMode) {
                alert("Exit doubt mode to draw.");
                return;
            }
            activeDrawTool = toolName;
            setMode('draw');
        }

        function toggleDoubtMode() {
            isDoubtMode = !isDoubtMode;
            const btn = document.getElementById('btnDoubtMode');
            const overlay = document.getElementById('doubtOverlayMsg');

            if (isDoubtMode) {
                btn.classList.add('active');
                overlay.style.display = 'block';
                setMode('select');
                // Dim tools while in doubt mode to focus on measuring
                toolsRow.style.opacity = '0.3';
                toolsRow.style.pointerEvents = 'none';
            } else {
                // Return normal items
                items.forEach(it => { if (it.doubtResolved) { it.isDoubt = false; } });

                btn.classList.remove('active');
                overlay.style.display = 'none';
                setMode('pan');
                toolsRow.style.opacity = '1';
                toolsRow.style.pointerEvents = 'auto';
            }
            redraw();
        }

        function markSelectedAsDoubt() {
            if (selectedItem && selectedItem.type === 'line') {
                selectedItem.isDoubt = true;
                selectedItem.doubtResolved = false;
                selectedItem.catId = 'fs'; // Default reset
                selectedItem = null;
                document.getElementById('btnDelete').style.display = 'none';
                document.getElementById('btnMarkDoubt').style.display = 'none';
                redraw();
                syncState();
            }
        }

        function updateToolVisuals() {
            document.querySelectorAll('#toolsRow .btn').forEach(b => b.classList.remove('active'));
            const map = {
                'line_fs': 'toolLineFs',
                'point_sp': 'toolSp',
                'point_pp': 'toolPp',
                'circle_auto': 'toolCircle'
            };
            if (map[activeDrawTool]) document.getElementById(map[activeDrawTool]).classList.add('active');
        }

        // ==========================================================================
        // CANVAS EVENTS & GEOMETRY
        // ==========================================================================

        function getImgPos(e) {
            const r = cvs.getBoundingClientRect();
            let cx = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
            let cy = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
            return {
                x: (cx - r.left) / currentScale,
                y: (cy - r.top) / currentScale
            };
        }

        function findItemAt(x, y) {
            const th = 25 / currentScale; // Touch/Click threshold
            const visibleItems = isDoubtMode ? items.filter(i => i.isDoubt) : items;

            let candidates = [];

            // 1. Gather all valid candidates within threshold
            visibleItems.forEach((it, idx) => {
                let dist = Infinity;

                if (it.type === 'point') {
                    dist = Math.hypot(x - it.x, y - it.y);
                } else if (it.type === 'line') {
                    // Distance from point to line segment
                    const A = x - it.x1;
                    const B = y - it.y1;
                    const C = it.x2 - it.x1;
                    const D = it.y2 - it.y1;
                    const lenSq = C * C + D * D;
                    let param = -1;
                    if (lenSq !== 0) param = (A * C + B * D) / lenSq;
                    let xx, yy;
                    if (param < 0) {
                        xx = it.x1;
                        yy = it.y1;
                    } else if (param > 1) {
                        xx = it.x2;
                        yy = it.y2;
                    } else {
                        xx = it.x1 + param * C;
                        yy = it.y1 + param * D;
                    }
                    dist = Math.hypot(x - xx, y - yy);
                } else if (it.type === 'circle') {
                    // Distance to ring
                    dist = Math.abs(Math.hypot(x - it.x, y - it.y) - it.r);
                }

                if (dist < th) {
                    candidates.push({ item: it, dist: dist, index: idx }); // idx is local to visibleItems
                }
            });

            if (candidates.length === 0) return null;

            // 2. Priority Logic

            // A) Check if the "absolute last" item (most recently created) is a candidate.
            // Note: visibleItems preserves order. The last element in visibleItems is the most recent.
            const lastItem = visibleItems[visibleItems.length - 1];
            const isLastCandidate = candidates.find(c => c.item === lastItem);

            if (isLastCandidate) {
                return isLastCandidate.item; // Absolute priority to the most recent item immediately
            }

            // B) Otherwise, return the specific item that is CLOSEST to the click (Precision)
            // Sort by distance ascending
            candidates.sort((a, b) => a.dist - b.dist);

            return candidates[0].item;
        }

        // Attach Listeners
        viewport.addEventListener('mousedown', onDown);
        viewport.addEventListener('touchstart', onDown, { passive: false });
        window.addEventListener('mousemove', onMove);
        window.addEventListener('touchmove', onMove, { passive: false });
        window.addEventListener('mouseup', onUp);
        window.addEventListener('touchend', onUp);

        // --- CORE EVENT HANDLERS ---

        function onDown(e) {
            if (!activeSampleId && document.getElementById('mainMenu').style.display !== 'none') return;
            if (!activeSampleId) return;
            if (e.target !== cvs && e.target !== viewport && e.target.id !== 'doubtOverlayMsg') return;

            // 1. Doubt Mode Interaction
            if (isDoubtMode) {
                if (e.cancelable) e.preventDefault();
                const pos = getImgPos(e);
                if (selectedItem) {
                    // Already have a doubt item selected, now measuring it
                    isDragging = true;
                    startPos = pos;
                    mode = 'doubt_measure';
                } else {
                    // Try to pick a doubt item
                    const clicked = findItemAt(pos.x, pos.y);
                    if (clicked && clicked.isDoubt) {
                        selectedItem = clicked;
                        redraw();
                    } else {
                        selectedItem = null;
                        redraw();
                    }
                }
                return;
            }

            // 2. Calibration Measure Mode
            if (mode === 'measure') {
                if (e.cancelable) e.preventDefault();
                const pos = getImgPos(e);
                measurePoints.push(pos);
                redraw();
                if (measurePoints.length === 2) setTimeout(finishMeasureRef, 100);
                return;
            }

            // 3. Pan Mode
            if (mode === 'pan') {
                isDragging = true;
                panStart = {
                    x: e.changedTouches ? e.changedTouches[0].clientX : e.clientX,
                    y: e.changedTouches ? e.changedTouches[0].clientY : e.clientY,
                    sx: viewport.scrollLeft,
                    sy: viewport.scrollTop
                };
            }
            // 4. Draw Mode
            else if (mode === 'draw') {
                if (!img.src) return;
                if (e.cancelable) e.preventDefault();
                isDragging = true;
                startPos = getImgPos(e);
            }
            // 5. Select (Edit) Mode
            else if (mode === 'select') {
                if (e.cancelable) e.preventDefault();
                const pos = getImgPos(e);
                const clicked = findItemAt(pos.x, pos.y);

                if (clicked) {
                    selectedItem = clicked;
                    isDragging = true;
                    startPos = pos;
                    dragItemStart = JSON.parse(JSON.stringify(selectedItem)); // Snapshot for relative movement

                    document.getElementById('btnDelete').style.display = 'inline-block';
                    if (clicked.type === 'line' && !isDoubtMode && !clicked.isDoubt) {
                        document.getElementById('btnMarkDoubt').style.display = 'inline-block';
                    }
                } else {
                    selectedItem = null;
                    document.getElementById('btnDelete').style.display = 'none';
                    document.getElementById('btnMarkDoubt').style.display = 'none';
                }
                redraw();
            }
        }

        function onMove(e) {
            if (!isDragging) return;

            // Doubt Measure Drag
            if (isDoubtMode && mode === 'doubt_measure') {
                e.preventDefault();
                const curr = getImgPos(e);
                // Calculate perpendicular projection to line
                const p1 = { x: selectedItem.x1, y: selectedItem.y1 };
                const p2 = { x: selectedItem.x2, y: selectedItem.y2 };
                let dx = p2.x - p1.x;
                let dy = p2.y - p1.y;

                if (dx === 0 && dy === 0) {
                    perpEndPos = curr;
                } else {
                    const len = Math.hypot(dx, dy);
                    const perpX = -dy / len;
                    const perpY = dx / len;

                    const dragX = curr.x - startPos.x;
                    const dragY = curr.y - startPos.y;

                    // Dot product to project drag vector onto normal vector
                    const dist = dragX * perpX + dragY * perpY;
                    perpEndPos = {
                        x: startPos.x + perpX * dist,
                        y: startPos.y + perpY * dist
                    };
                }
                redraw();

                // Draw live measurement line
                ctx.beginPath();
                ctx.moveTo(startPos.x, startPos.y);
                ctx.lineTo(perpEndPos.x, perpEndPos.y);
                ctx.strokeStyle = "white";
                ctx.lineWidth = 2 / currentScale;
                ctx.stroke();

                const wPx = Math.hypot(perpEndPos.x - startPos.x, perpEndPos.y - startPos.y);
                const wUm = isCalibrated ? (wPx / pixelsPerUnit) : 0;

                ctx.fillStyle = "white";
                ctx.font = "bold " + (14 / currentScale) + "px Arial";
                ctx.fillText((isCalibrated ? wUm.toFixed(1) + " ¬µm" : "No Calib"), perpEndPos.x + 10, perpEndPos.y);
                return;
            }

            // Pan Drag
            if (mode === 'pan') {
                e.preventDefault();
                let cx = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
                let cy = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
                viewport.scrollLeft = panStart.sx - (cx - panStart.x);
                viewport.scrollTop = panStart.sy - (cy - panStart.y);
            }
            // Draw Drag
            else if (mode === 'draw') {
                e.preventDefault();
                const curr = getImgPos(e);
                redraw();

                // Render Live Preview
                if (activeDrawTool.startsWith('line_')) {
                    ctx.beginPath();
                    ctx.moveTo(startPos.x, startPos.y);
                    ctx.lineTo(curr.x, curr.y);
                    ctx.strokeStyle = CATS.fs.color;
                    ctx.lineWidth = 4 / currentScale;
                    ctx.stroke();
                } else if (activeDrawTool === 'circle_auto') {
                    const r = Math.hypot(curr.x - startPos.x, curr.y - startPos.y);
                    ctx.beginPath();
                    ctx.arc(startPos.x, startPos.y, r, 0, Math.PI * 2);
                    ctx.strokeStyle = "#888";
                    ctx.lineWidth = 2 / currentScale;
                    ctx.stroke();

                    const diaUm = getMicrometers(r * 2);
                    ctx.fillStyle = "white";
                    ctx.font = (12 / currentScale) + "px Arial";
                    ctx.fillText(isCalibrated ? diaUm.toFixed(1) + "¬µm" : "No Calib", curr.x, curr.y);
                }
            }
            // Move Item (Select)
            else if (mode === 'select' && selectedItem) {
                e.preventDefault();
                const curr = getImgPos(e);
                const dx = curr.x - startPos.x;
                const dy = curr.y - startPos.y;

                if (selectedItem.type === 'point' || selectedItem.type === 'circle') {
                    selectedItem.x = dragItemStart.x + dx;
                    selectedItem.y = dragItemStart.y + dy;
                } else {
                    selectedItem.x1 = dragItemStart.x1 + dx;
                    selectedItem.y1 = dragItemStart.y1 + dy;
                    selectedItem.x2 = dragItemStart.x2 + dx;
                    selectedItem.y2 = dragItemStart.y2 + dy;
                }
                redraw();
            }
        }

        function onUp(e) {
            if (!isDragging) return;
            isDragging = false;

            // Finish Doubt Measure
            if (isDoubtMode && mode === 'doubt_measure') {
                if (!isCalibrated) {
                    alert("You must calibrate first!");
                    redraw();
                    return;
                }
                const distPx = Math.hypot(perpEndPos.x - startPos.x, perpEndPos.y - startPos.y);
                const widthUm = distPx / pixelsPerUnit;

                // Auto-classify based on width
                if (widthUm < 5) selectedItem.catId = 'fs';         // Fine Scratch
                else if (widthUm < 15) selectedItem.catId = 'cs';   // Coarse Scratch
                else selectedItem.catId = 'hcs';                    // Hyper-Coarse Scratch

                selectedItem.doubtResolved = true;
                selectedItem.widthVal = widthUm;
                selectedItem = null;
                syncState();
                redraw();
                saveHistory(); // ACTION: Doubt Resolve
                return;
            }

            // Finish Drawing
            if (mode === 'draw') {
                const curr = getImgPos(e);
                const dist = Math.hypot(curr.x - startPos.x, curr.y - startPos.y);
                let newItem = null;

                if (activeDrawTool.startsWith('point_')) {
                    newItem = {
                        type: 'point',
                        catId: activeDrawTool === 'point_sp' ? 'sp' : 'pp',
                        x: curr.x, y: curr.y
                    };
                } else if (activeDrawTool === 'circle_auto') {
                    if (dist > 2 / currentScale) {
                        let cat = 'sp';
                        if (isCalibrated) {
                            const dia = (dist * 2) / pixelsPerUnit;
                            if (dia >= 10 && dia <= 55) cat = 'lp';
                            else if (dia > 55) cat = 'g';
                        }
                        newItem = { type: 'circle', catId: cat, x: startPos.x, y: startPos.y, r: dist };
                    }
                } else if (activeDrawTool === 'line_fs') {
                    if (dist > 5 / currentScale) {
                        newItem = { type: 'line', catId: 'fs', x1: startPos.x, y1: startPos.y, x2: curr.x, y2: curr.y };
                    }
                }

                if (newItem) {
                    items.push(newItem);
                    syncState();
                    saveHistory(); // ACTION: Draw
                }
                redraw();
            }

            // Finish Move (Select)
            if (mode === 'select') {
                if (selectedItem) {
                    syncState();
                    saveHistory(); // ACTION: Move/Edit
                }
            }
        }

        // ==========================================================================
        // EDITING UTILS (UNDO/REDO/DELETE) w/ SNAPSHOT HISTORY
        // ==========================================================================

        const MAX_HISTORY = 50;
        let historyStack = [];
        let historyIndex = -1;

        function resetHistory() {
            historyStack = [];
            historyIndex = -1;
            saveHistory(); // Auto-save initial state
        }

        function saveHistory() {
            // 1. Truncate any "future" history (if we undid then did something new)
            if (historyIndex < historyStack.length - 1) {
                historyStack = historyStack.slice(0, historyIndex + 1);
            }

            // 2. Snapshot current state
            const snapshot = JSON.parse(JSON.stringify(items));
            historyStack.push(snapshot);
            historyIndex++;

            // 3. Limit size
            if (historyStack.length > MAX_HISTORY) {
                historyStack.shift();
                historyIndex--;
            }

            // UI Update (Optional: Enable/Disable buttons based on index)
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                restoreStateFromHistory();
            }
        }

        function redo() {
            if (historyIndex < historyStack.length - 1) {
                historyIndex++;
                restoreStateFromHistory();
            }
        }

        function restoreStateFromHistory() {
            const snapshot = historyStack[historyIndex];
            // Deep copy back to items to avoid reference issues
            items = JSON.parse(JSON.stringify(snapshot));
            selectedItem = null; // Deselect on undo/redo to avoid ghost selections
            document.getElementById('btnDelete').style.display = 'none';
            document.getElementById('btnMarkDoubt').style.display = 'none';
            redraw();
            syncState();
        }

        function deleteSelected() {
            if (selectedItem) {
                items = items.filter(i => i !== selectedItem);
                selectedItem = null;
                document.getElementById('btnDelete').style.display = 'none';
                document.getElementById('btnMarkDoubt').style.display = 'none';
                redraw();
                syncState();
            }
        }

        // ==========================================================================
        // ZOOM & VIEWPORT
        // ==========================================================================

        function updateZoom(val) {
            currentScale = val / 100;
            document.getElementById('zoomLabel').innerText = Math.round(val) + '%';
            document.getElementById('zoomSlider').value = val;
            if (img.src) {
                cvs.style.width = (img.width * currentScale) + "px";
                cvs.style.height = (img.height * currentScale) + "px";
            }
        }

        function changeZoom(delta) {
            let newVal = parseInt(zoomSlider.value) + delta;
            newVal = Math.max(10, Math.min(400, newVal));
            updateZoom(newVal);
        }

        function fitToScreen() {
            if (!img.src) return;
            const vw = viewport.clientWidth - 20;
            const vh = viewport.clientHeight - 20;
            const ratioW = vw / img.width;
            const ratioH = vh / img.height;
            const bestRatio = Math.min(ratioW, ratioH);
            updateZoom(Math.floor(bestRatio * 100));

            // Center
            viewport.scrollLeft = (cvs.scrollWidth - viewport.clientWidth) / 2;
            viewport.scrollTop = (cvs.scrollHeight - viewport.clientHeight) / 2;
        }

        // ==========================================================================
        // CALIBRATION LOGIC
        // ==========================================================================

        function openCalibration() {
            document.getElementById('modalOverlay').style.display = 'flex';
        }

        function closeModal() {
            document.getElementById('modalOverlay').style.display = 'none';
            setMode('pan');
        }

        function startMeasureRef() {
            if (!img.src) {
                alert("Load image first!");
                return;
            }
            closeModal();
            setMode('measure');
            measurePoints = [];
            alert("Click the two ends of the scale bar.");
        }

        function finishMeasureRef() {
            const d = Math.hypot(measurePoints[1].x - measurePoints[0].x, measurePoints[1].y - measurePoints[0].y);
            document.getElementById('modalOverlay').style.display = 'flex';
            document.getElementById('manualInputArea').style.opacity = '1';
            document.getElementById('manualInputArea').style.pointerEvents = 'auto';
            document.getElementById('pixelReadout').innerText = "px: " + d.toFixed(1);
            document.getElementById('manualInputArea').dataset.d = d;
            setMode('pan');
        }

        function applyManual() {
            const d = parseFloat(document.getElementById('manualInputArea').dataset.d);
            const val = parseFloat(document.getElementById('manInput').value);
            const unit = document.getElementById('manUnit').value;
            if (!img.src) { alert("Load image first!"); return; }
            if (!val) { alert("Enter valid number!"); return; }
            pixelsPerUnit = d / val;
            unitName = unit;
            isCalibrated = true;
            syncState();
            closeModal();
            redraw();
            alert("Calibrated!");
        }

        function applyFOV() {
            const val = parseFloat(document.getElementById('fovInput').value);
            const unit = document.getElementById('fovUnit').value;
            if (!img.src) { alert("Load image first!"); return; }
            if (!val) { alert("Enter valid number!"); return; }
            pixelsPerUnit = img.width / val;
            unitName = unit;
            isCalibrated = true;
            syncState();
            closeModal();
            redraw();
            alert("Calibrated!");
        }

        function getMicrometers(px) {
            if (!isCalibrated) return 0;
            const val = px / pixelsPerUnit;
            if (unitName === 'mm') return val * 1000;
            if (unitName === 'm') return val * 1000000;
            if (unitName === 'nm') return val / 1000;
            return val;
        }

        // ==========================================================================
        // CANVAS RENDERING (REDRAW)
        // ==========================================================================

        function redraw() {
            try {
                ctx.clearRect(0, 0, cvs.width, cvs.height);
                if (img.src && img.width > 0) ctx.drawImage(img, 0, 0);

                let counts = {};
                STATS_ORDER.forEach(k => counts[k] = 0);
                const baseW = Math.max(3, (img.width || 1000) / 500);

                if (items && items.length > 0) {
                    items.forEach(it => {
                        // Filter for doubt mode
                        if (isDoubtMode && !it.isDoubt) return;

                        const catId = it.catId && CATS[it.catId] ? it.catId : 'sp';
                        const conf = CATS[catId];
                        const isSel = (it === selectedItem);
                        let drawColor = conf.color;

                        if (it.isDoubt) {
                            if (it.doubtResolved) drawColor = conf.color;
                            else drawColor = "#ffd60a"; // Highlight unresolved doubts
                        }
                        if (isSel) drawColor = "#00ffff"; // Selection Highlight

                        ctx.strokeStyle = drawColor;
                        ctx.fillStyle = drawColor;
                        ctx.lineWidth = isSel ? baseW * 2 : baseW;

                        // Shadow for visibility
                        ctx.shadowBlur = (isSel || (it.isDoubt && !it.doubtResolved)) ? 10 : 0;
                        ctx.shadowColor = "black";

                        // Dashed line for unresolved doubts
                        if (it.isDoubt && !it.doubtResolved) ctx.setLineDash([baseW * 2, baseW * 2]);
                        else ctx.setLineDash([]);

                        if (it.type === 'point') {
                            ctx.beginPath();
                            ctx.arc(it.x, it.y, baseW * 2.5, 0, Math.PI * 2);
                            ctx.fill();
                        } else if (it.type === 'line') {
                            ctx.beginPath();
                            ctx.moveTo(it.x1, it.y1);
                            ctx.lineTo(it.x2, it.y2);
                            ctx.stroke();
                            // End Point Marker
                            ctx.beginPath();
                            ctx.arc(it.x2, it.y2, baseW * 1.5, 0, Math.PI * 2);
                            ctx.fill();

                            // Show measurement if relevant
                            if (it.widthVal && (isDoubtMode || isSel)) {
                                ctx.font = (baseW * 3) + "px Arial";
                                ctx.fillStyle = "white";
                                ctx.fillText(it.widthVal.toFixed(1) + "¬µm", (it.x1 + it.x2) / 2, (it.y1 + it.y2) / 2);
                            }
                        } else if (it.type === 'circle') {
                            ctx.beginPath();
                            ctx.arc(it.x, it.y, it.r, 0, Math.PI * 2);
                            ctx.stroke();
                        }

                        if (counts[catId] !== undefined) counts[catId]++;
                    });
                }

                ctx.setLineDash([]);
                ctx.shadowBlur = 0;

                // Render Measurement Points
                if (mode === 'measure') {
                    ctx.fillStyle = "#ff00ff";
                    measurePoints.forEach((p, i) => {
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, baseW * 3, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.font = (baseW * 4) + "px Arial";
                        ctx.fillStyle = "white";
                        ctx.fillText(i + 1, p.x, p.y);
                    });
                }

                // Update Stats Bar
                let html = isCalibrated ? `<span style="color:var(--text-sec); font-size:10px;">(1 ${unitName} = ${pixelsPerUnit.toFixed(1)}px)</span> | ` : `<span style="color:red">NO CALIB</span> | `;
                STATS_ORDER.forEach(k => {
                    const c = CATS[k];
                    html += `<span style="color:${c.color}">${c.label}: ${counts[k]}</span> | `;
                });
                statsBar.innerHTML = html.slice(0, -3);

            } catch (e) { console.error("Redraw error:", e); }
        }

        // ==========================================================================
        // IMAGE DOWNLOAD UTILS
        // ==========================================================================

        function downloadImg() {
            try {
                if (!img.src) { alert("No image loaded/visible to download."); return; }
                const p = selectedItem;
                selectedItem = null;
                redraw();

                const l = document.createElement('a');
                l.download = currentFileName + "_samp.jpg";
                l.href = cvs.toDataURL('image/jpeg', 0.9);
                l.click();

                selectedItem = p; // Restore selection
                redraw();
            } catch (e) { alert("Export Error: " + e.message); }
        }

        function downloadImgWithCounts() {
            try {
                if (!img.src) { alert("No image loaded/visible to download."); return; }
                const p = selectedItem;
                selectedItem = null;

                // Draw clean image first
                ctx.clearRect(0, 0, cvs.width, cvs.height);
                ctx.drawImage(img, 0, 0);
                redraw();

                let counts = {};
                STATS_ORDER.forEach(k => counts[k] = 0);
                if (items) items.forEach(it => { if (counts[it.catId] !== undefined) counts[it.catId]++ });

                let statsText = `Calib: ${isCalibrated ? 'YES' : 'NO'} | `;
                STATS_ORDER.forEach(k => {
                    if (CATS[k]) statsText += `${CATS[k].label}: ${counts[k]} | `;
                });

                const H = cvs.height;
                const W = cvs.width;
                const barH = Math.max(30, H * 0.05);

                // Draw Stats Banner
                ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
                ctx.fillRect(0, H - barH, W, barH);

                ctx.fillStyle = "black";
                ctx.font = "bold " + (barH * 0.5) + "px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(statsText, W / 2, H - barH / 2);

                const l = document.createElement('a');
                l.download = currentFileName + "_count.jpg";
                l.href = cvs.toDataURL('image/jpeg', 0.9);
                l.click();

                selectedItem = p;
                redraw();
            } catch (e) { alert("Export Error: " + e.message); }
        }

        // Start App
        createNewSample(false);

    </script>
</body>

</html>