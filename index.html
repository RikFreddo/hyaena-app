<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hyaena</title>
    
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#e3dac9">
    <link rel="apple-touch-icon" href="icon.png">
    
    <style>
        /* GENERAL STYLES */
        html, body { 
            margin: 0; padding: 0; width: 100%; height: 100%; 
            background-color: #222; 
            font-family: -apple-system, BlinkMacSystemFont, sans-serif; 
            display: flex; flex-direction: column; overflow: hidden;
            overscroll-behavior-y: none;
        }

        /* TOOLBAR */
        #toolbar {
            flex-shrink: 0; background: #fff; padding: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4); z-index: 1000;
            display: flex; flex-direction: column; gap: 8px;
        }

        .row { display: flex; justify-content: center; align-items: center; gap: 6px; flex-wrap: wrap; }

        /* BUTTONS */
        .btn {
            padding: 8px 12px; border-radius: 6px; border: 1px solid #ccc; background: #f2f2f7; 
            font-size: 13px; font-weight: 600; cursor: pointer; color: #333; display: flex; align-items: center; gap: 5px;
        }
        .btn.active { background-color: #007aff; color: white; border-color: #005bb5; }
        
        .btn-green { background-color: #34c759; color: white; border: none; } 
        .btn-blue { background-color: #007aff; color: white; border: none; } 
        .btn-red { background-color: #ff3b30; color: white; border: none; }
        .btn-calib { background-color: #ff9500; color: white; border: none; }
        .btn-excel { background-color: #1d6f42; color: white; border: none; }
        .btn-zoom { padding: 4px 10px; font-size: 16px; min-width: 30px; justify-content: center; }

        /* Doubt Mode Button */
        .btn-doubt-mode { border: 2px solid #ffd60a; background: #fffbe6; color: #b48900; }
        .btn-doubt-mode.active { background: #ffd60a; color: #000; border-color: #b48900; animation: pulse 2s infinite; }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(255, 214, 10, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(255, 214, 10, 0); } 100% { box-shadow: 0 0 0 0 rgba(255, 214, 10, 0); } }

        .btn-mark-doubt { background-color: #666; color: #ffd60a; border: 1px solid #ffd60a; }

        input[type="file"] { display: none; }
        .file-label { padding: 6px 10px; border-radius: 6px; background: #e5e5ea; font-size: 12px; cursor: pointer; border: 1px solid #ccc; }

        #zoomContainer { display: flex; align-items: center; gap: 5px; background: #f2f2f7; padding: 4px 8px; border-radius: 15px; border: 1px solid #ddd; }
        input[type=range] { width: 80px; }

        #stats-bar {
            background: #f9f9f9; padding: 6px; font-size: 12px; font-weight: 600;
            border-bottom: 1px solid #ccc; text-align: center; color: #333;
            display: flex; flex-wrap: wrap; justify-content: center; gap: 12px;
        }

        /* VIEWPORT */
        #viewport {
            flex-grow: 1; 
            overflow: auto; 
            position: relative; 
            background-color: #444;
            display: flex; 
            touch-action: none; 
            -webkit-overflow-scrolling: touch;
        }
        
        canvas { 
            display: block; 
            background: white; 
            box-shadow: 0 0 30px rgba(0,0,0,0.5); 
            margin: auto; 
        }
        
        /* Cursors */
        .mode-pan canvas { cursor: grab; }
        .mode-draw canvas { cursor: crosshair; }
        .mode-select canvas { cursor: pointer; }
        .mode-measure canvas { cursor: crosshair; }

        #doubtOverlayMsg {
            position: fixed; top: 100px; left: 50%; transform: translateX(-50%);
            background: rgba(255, 214, 10, 0.95); color: black; padding: 8px 20px;
            border-radius: 20px; font-weight: bold; font-size: 13px; pointer-events: none; display: none;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3); z-index: 500; border: 1px solid #b48900;
        }

        /* MODAL */
        #modalOverlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 2000; justify-content: center; align-items: center; }
        #modalBox { background: white; padding: 20px; border-radius: 12px; width: 90%; max-width: 350px; box-shadow: 0 10px 25px rgba(0,0,0,0.3); text-align: center; }
        .modal-section { margin-bottom: 15px; padding-bottom: 15px; border-bottom: 1px solid #eee; }
        .inp-num { padding: 8px; width: 80px; border: 1px solid #ccc; border-radius: 4px; font-size: 16px; }
        .inp-sel { padding: 8px; border: 1px solid #ccc; border-radius: 4px; font-size: 16px; background: white; }
    </style>
</head>
<body>

    <div id="toolbar">
        <div class="row">
            <label class="file-label">üì∑ New<input type="file" id="inpFile" accept="image/*"></label>
            <label class="file-label">üìÇ Open<input type="file" id="inpProject" accept=".json"></label>
            <button class="btn btn-blue" onclick="saveProject()">üíæ Save</button>
            <button class="btn btn-green" onclick="downloadImg()">üñºÔ∏è JPG</button>
            <button class="btn btn-green" onclick="downloadImgWithCounts()">üì∏+üìä Info</button>
            <button class="btn btn-excel" onclick="exportExcel()">üìä Excel</button>
            <button class="btn btn-calib" onclick="openCalibration()">üìê Calib</button>
        </div>

        <div class="row">
            <div id="zoomContainer">
                <button class="btn btn-zoom" onclick="changeZoom(-10)">-</button>
                <input type="range" id="zoomSlider" min="10" max="400" value="100" oninput="updateZoom(this.value)">
                <button class="btn btn-zoom" onclick="changeZoom(10)">+</button>
                <button class="btn" style="padding:4px 8px; font-size:11px;" onclick="fitToScreen()">Fit</button>
                <span id="zoomLabel" style="font-size:11px; width:35px; text-align:right;">100%</span>
            </div>
            <div style="width:1px; height:20px; background:#ccc; margin:0 5px;"></div>
            <button id="btnPan" class="btn active" onclick="setMode('pan')">‚úã Pan</button>
            <button id="btnSelect" class="btn" onclick="setMode('select')">üëÜ Edit</button>
            <div style="width:1px; height:20px; background:#ccc; margin:0 5px;"></div>
            <button id="btnDoubtMode" class="btn btn-doubt-mode" onclick="toggleDoubtMode()">‚ö†Ô∏è Doubt Mode</button>
        </div>

        <div class="row" id="toolsRow">
            <button id="toolLineFs" class="btn active" onclick="setDrawTool('line_fs')" style="border-left:5px solid #ff3b30">üìè Scratches</button>
            <button id="toolSp" class="btn" onclick="setDrawTool('point_sp')" style="border-left:5px solid #007aff">üîµ Sp</button>
            <button id="toolPp" class="btn" onclick="setDrawTool('point_pp')" style="border-left:5px solid #ff9500">üü† Pp</button>
            <button id="toolCircle" class="btn" onclick="setDrawTool('circle_auto')" style="border-left:5px solid #555">‚≠ï Auto</button>
            <div style="width:1px; height:20px; background:#ccc; margin:0 5px;"></div>
            <button id="btnMarkDoubt" class="btn btn-mark-doubt" onclick="markSelectedAsDoubt()" style="display:none;">‚ùì Mark Doubt</button>
            <button id="btnDelete" class="btn btn-red" onclick="deleteSelected()" style="display:none;">üóëÔ∏è Delete</button>
            <button class="btn" onclick="undo()" id="btnUndo">‚Ü© Undo</button>
            <button class="btn" onclick="redo()" id="btnRedo">‚Ü™ Redo</button>
        </div>
    </div>

    <div id="stats-bar">Load photo and calibrate.</div>

    <div id="viewport" class="mode-pan">
        <div id="doubtOverlayMsg">‚ö†Ô∏è DOUBT MODE: Drag to measure (Perpendicular)</div>
        <canvas id="cvs" style="display:none;"></canvas>
    </div>

    <div id="modalOverlay">
        <div id="modalBox">
            <h3>Calibration</h3>
            <div class="modal-section">
                <h4>Method 1: FOV</h4>
                <input type="number" id="fovInput" class="inp-num" placeholder="Ex. 500">
                <select id="fovUnit" class="inp-sel">
                    <option value="¬µm">¬µm</option> <option value="mm">mm</option>
                </select>
                <br><br><button class="btn btn-blue" onclick="applyFOV()">Apply</button>
            </div>
            <div class="modal-section" style="border-bottom:none;">
                <h4>Method 2: Manual</h4>
                <button class="btn" onclick="startMeasureRef()">üìç Pick 2 points</button>
                <br><br>
                <div id="manualInputArea" style="opacity:0.5; pointer-events:none;">
                    <span id="pixelReadout" style="font-size:11px; font-weight:bold;">px: 0</span><br>
                    <input type="number" id="manInput" class="inp-num" placeholder="Dist.">
                    <select id="manUnit" class="inp-sel">
                        <option value="¬µm">¬µm</option> <option value="mm">mm</option>
                    </select>
                    <br><br>
                    <button class="btn btn-blue" onclick="applyManual()">Apply Manual</button>
                </div>
            </div>
            <button class="btn btn-red" onclick="closeModal()" style="width:100%">Close</button>
        </div>
    </div>

    <script>
        // SERVICE WORKER REGISTRATION
        if ('serviceWorker' in navigator) {
           navigator.serviceWorker.register('sw.js');
        }

        const CATS = {
            'sp':  { label: 'Sp',  color: '#007aff' }, 
            'lp':  { label: 'Lp',  color: '#af52de' }, 
            'g':   { label: 'G',   color: '#000000' }, 
            'pp':  { label: 'Pp',  color: '#ff9500' }, 
            'fs':  { label: 'Fs',  color: '#ff3b30' }, 
            'cs':  { label: 'Cs',  color: '#ffcc00' }, 
            'hcs': { label: 'HCs', color: '#34c759' }  
        };
        const STATS_ORDER = ['sp', 'lp', 'pp', 'g', 'fs', 'cs', 'hcs'];

        const cvs = document.getElementById('cvs');
        const ctx = cvs.getContext('2d');
        const viewport = document.getElementById('viewport');
        const statsBar = document.getElementById('stats-bar');
        const zoomSlider = document.getElementById('zoomSlider');
        
        let img = new Image();
        let items = []; 
        let redoStack = []; 
        let currentFileName = "result"; 

        let mode = 'pan'; 
        let activeDrawTool = 'line_fs'; 
        let currentScale = 1;
        let isDoubtMode = false;
        let pixelsPerUnit = 1; let unitName = "px"; let isCalibrated = false;

        let isDragging = false;
        let startPos = {x:0, y:0};
        let panStart = {x:0, y:0};
        let selectedItem = null;
        let dragItemStart = null;
        let measurePoints = []; 
        let perpEndPos = {x:0, y:0};

        // --- MODE MANAGEMENT ---
        function setMode(m) {
            mode = m;
            viewport.className = 'mode-' + m;
            ['btnPan', 'btnSelect'].forEach(id => document.getElementById(id).classList.remove('active'));
            if(m === 'pan') document.getElementById('btnPan').classList.add('active');
            if(m === 'select') document.getElementById('btnSelect').classList.add('active');
            
            if(m === 'draw') updateToolVisuals();
            else document.querySelectorAll('#toolsRow .btn').forEach(b => { if(!b.id.startsWith('btn')) b.classList.remove('active'); });

            if(m !== 'select' && m !== 'doubt_measure' && m !== 'measure') {
                selectedItem = null; toggleActionButtons(false); redraw();
            }
        }

        function setDrawTool(toolName) {
            if(isDoubtMode) { alert("Exit doubt mode to draw."); return; }
            activeDrawTool = toolName; setMode('draw');
        }

        function toggleDoubtMode() {
            isDoubtMode = !isDoubtMode;
            const btn = document.getElementById('btnDoubtMode');
            const overlay = document.getElementById('doubtOverlayMsg');
            if(isDoubtMode) {
                btn.classList.add('active'); overlay.style.display = 'block';
                setMode('select'); 
                document.getElementById('toolsRow').style.opacity = '0.3'; document.getElementById('toolsRow').style.pointerEvents = 'none';
            } else {
                items.forEach(it => { if(it.doubtResolved) { it.isDoubt = false; } });
                btn.classList.remove('active'); overlay.style.display = 'none';
                setMode('pan');
                document.getElementById('toolsRow').style.opacity = '1'; document.getElementById('toolsRow').style.pointerEvents = 'auto';
            }
            redraw();
        }

        function markSelectedAsDoubt() {
            if(selectedItem && selectedItem.type === 'line') {
                selectedItem.isDoubt = true; selectedItem.doubtResolved = false; selectedItem.catId = 'fs'; 
                selectedItem = null; toggleActionButtons(false); redraw();
            }
        }

        function updateToolVisuals() {
            document.querySelectorAll('#toolsRow .btn').forEach(b => b.classList.remove('active'));
            const map = {'line_fs': 'toolLineFs', 'point_sp': 'toolSp', 'point_pp': 'toolPp', 'circle_auto': 'toolCircle'};
            if(map[activeDrawTool]) document.getElementById(map[activeDrawTool]).classList.add('active');
        }

        function getPerpendicularPoint(lineStart, lineEnd, clickStart, clickCurr) {
            let dx = lineEnd.x - lineStart.x; let dy = lineEnd.y - lineStart.y;
            if(dx === 0 && dy === 0) return clickCurr;
            const len = Math.hypot(dx, dy); const perpX = -dy / len; const perpY = dx / len;
            const dragX = clickCurr.x - clickStart.x; const dragY = clickCurr.y - clickStart.y;
            const dist = dragX * perpX + dragY * perpY;
            return { x: clickStart.x + perpX * dist, y: clickStart.y + perpY * dist };
        }

        // --- INPUT HANDLING ---
        function getImgPos(e) {
            const r = cvs.getBoundingClientRect();
            let cx = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
            let cy = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
            return { x: (cx - r.left) / currentScale, y: (cy - r.top) / currentScale };
        }

        viewport.addEventListener('mousedown', onDown);
        viewport.addEventListener('touchstart', onDown, {passive: false});
        window.addEventListener('mousemove', onMove);
        window.addEventListener('touchmove', onMove, {passive: false});
        window.addEventListener('mouseup', onUp);
        window.addEventListener('touchend', onUp);

        function onDown(e) {
            if(!img.src) return;
            // FIX GHOST CLICKS
            if(e.target !== cvs && e.target !== viewport && e.target.id !== 'doubtOverlayMsg') return;

            if(isDoubtMode) {
                if(e.cancelable) e.preventDefault();
                const pos = getImgPos(e);
                if(selectedItem) {
                    isDragging = true; startPos = pos; mode = 'doubt_measure'; 
                } else {
                    const clicked = findItemAt(pos.x, pos.y);
                    if(clicked && clicked.isDoubt) { selectedItem = clicked; redraw(); } 
                    else { selectedItem = null; redraw(); }
                }
                return;
            }

            if(mode === 'measure') {
                if(e.cancelable) e.preventDefault();
                const pos = getImgPos(e);
                measurePoints.push(pos);
                redraw();
                if(measurePoints.length === 2) {
                    setTimeout(finishMeasureRef, 100);
                }
                return;
            }

            if(mode === 'pan') {
                isDragging = true;
                panStart = { x: e.changedTouches?e.changedTouches[0].clientX:e.clientX, y: e.changedTouches?e.changedTouches[0].clientY:e.clientY, sx: viewport.scrollLeft, sy: viewport.scrollTop };
            } 
            else if(mode === 'draw') {
                if(e.cancelable) e.preventDefault(); isDragging = true; startPos = getImgPos(e);
            }
            else if(mode === 'select') {
                if(e.cancelable) e.preventDefault();
                const pos = getImgPos(e);
                const clicked = findItemAt(pos.x, pos.y);
                if(clicked) {
                    selectedItem = clicked; isDragging = true; startPos = pos;
                    dragItemStart = JSON.parse(JSON.stringify(selectedItem)); toggleActionButtons(true);
                } else {
                    selectedItem = null; toggleActionButtons(false);
                }
                redraw();
            }
        }

        function onMove(e) {
            if(!isDragging) return;
            
            if(isDoubtMode && mode === 'doubt_measure') {
                e.preventDefault();
                const curr = getImgPos(e);
                const p1 = {x: selectedItem.x1, y: selectedItem.y1};
                const p2 = {x: selectedItem.x2, y: selectedItem.y2};
                perpEndPos = getPerpendicularPoint(p1, p2, startPos, curr);
                redraw(); 
                ctx.beginPath(); ctx.moveTo(startPos.x, startPos.y); ctx.lineTo(perpEndPos.x, perpEndPos.y);
                ctx.strokeStyle = "white"; ctx.lineWidth = 2/currentScale; ctx.stroke();
                const wPx = Math.hypot(perpEndPos.x - startPos.x, perpEndPos.y - startPos.y);
                const wUm = getMicrometers(wPx);
                ctx.fillStyle = "white"; ctx.font = "bold "+(14/currentScale)+"px Arial";
                ctx.fillText((isCalibrated ? wUm.toFixed(1)+" ¬µm" : "No Calib"), perpEndPos.x+10, perpEndPos.y);
                return;
            }

            if(mode === 'pan') {
                e.preventDefault();
                let cx = e.changedTouches?e.changedTouches[0].clientX:e.clientX;
                let cy = e.changedTouches?e.changedTouches[0].clientY:e.clientY;
                viewport.scrollLeft = panStart.sx - (cx - panStart.x); viewport.scrollTop = panStart.sy - (cy - panStart.y);
            }
            else if(mode === 'draw') {
                e.preventDefault();
                const curr = getImgPos(e); redraw();
                if(activeDrawTool.startsWith('line_')) {
                    ctx.beginPath(); ctx.moveTo(startPos.x, startPos.y); ctx.lineTo(curr.x, curr.y);
                    ctx.strokeStyle = CATS.fs.color; ctx.lineWidth = 4/currentScale; ctx.stroke();
                } else if(activeDrawTool === 'circle_auto') {
                    const r = Math.hypot(curr.x - startPos.x, curr.y - startPos.y);
                    ctx.beginPath(); ctx.arc(startPos.x, startPos.y, r, 0, Math.PI*2);
                    ctx.strokeStyle = "#888"; ctx.lineWidth = 2/currentScale; ctx.stroke();
                    const diaUm = getMicrometers(r*2); ctx.fillStyle="white"; ctx.font=(12/currentScale)+"px Arial";
                    ctx.fillText(isCalibrated?diaUm.toFixed(1)+"¬µm":"No Calib", curr.x, curr.y);
                }
            }
            else if(mode === 'select' && selectedItem) {
                e.preventDefault(); const curr = getImgPos(e);
                const dx = curr.x - startPos.x; const dy = curr.y - startPos.y;
                if(selectedItem.type === 'point' || selectedItem.type === 'circle') { selectedItem.x = dragItemStart.x + dx; selectedItem.y = dragItemStart.y + dy; } 
                else { selectedItem.x1 = dragItemStart.x1 + dx; selectedItem.y1 = dragItemStart.y1 + dy; selectedItem.x2 = dragItemStart.x2 + dx; selectedItem.y2 = dragItemStart.y2 + dy; }
                redraw();
            }
        }

        function onUp(e) {
            if(!isDragging) return; isDragging = false;

            if(isDoubtMode && mode === 'doubt_measure') {
                if(!isCalibrated) { alert("You must calibrate first!"); redraw(); return; }
                const distPx = Math.hypot(perpEndPos.x - startPos.x, perpEndPos.y - startPos.y);
                const widthUm = getMicrometers(distPx);
                if(widthUm < 5) selectedItem.catId = 'fs'; else if(widthUm < 15) selectedItem.catId = 'cs'; else selectedItem.catId = 'hcs';
                selectedItem.doubtResolved = true; selectedItem.widthVal = widthUm; 
                selectedItem = null; redraw(); return;
            }

            if(mode === 'draw') {
                const curr = getImgPos(e); const dist = Math.hypot(curr.x - startPos.x, curr.y - startPos.y);
                let newItem = null;
                
                if(activeDrawTool.startsWith('point_')) { newItem = { type:'point', catId: activeDrawTool==='point_sp'?'sp':'pp', x: curr.x, y: curr.y }; }
                else if(activeDrawTool === 'circle_auto') {
                    if(dist > 5/currentScale) {
                        let cat = 'sp';
                        if(isCalibrated) { const dia = getMicrometers(dist*2); if(dia >= 10 && dia <= 55) cat = 'lp'; else if(dia > 55) cat = 'g'; }
                        newItem = { type:'circle', catId: cat, x: startPos.x, y: startPos.y, r: dist };
                    }
                }
                else if(activeDrawTool === 'line_fs') { if(dist > 5/currentScale) { newItem = { type:'line', catId: 'fs', x1: startPos.x, y1: startPos.y, x2: curr.x, y2: curr.y }; } }
                
                if(newItem) {
                    items.push(newItem);
                    redoStack = []; 
                }
                redraw();
            }
        }

        function redraw() {
            ctx.clearRect(0,0, cvs.width, cvs.height);
            if(img.src) ctx.drawImage(img, 0, 0);

            let counts = {}; STATS_ORDER.forEach(k => counts[k]=0);
            const baseW = Math.max(3, img.width / 500);

            items.forEach(it => {
                if(isDoubtMode && !it.isDoubt) return; 
                const conf = CATS[it.catId] || CATS.sp;
                const isSel = (it === selectedItem);
                
                let drawColor = conf.color;
                if(it.isDoubt) {
                    if(it.doubtResolved) drawColor = conf.color; 
                    else drawColor = "#ffd60a"; 
                }
                if(isSel) drawColor = "#00ffff";

                ctx.strokeStyle = drawColor; ctx.fillStyle = drawColor;
                ctx.lineWidth = isSel ? baseW*2 : baseW;
                ctx.shadowBlur = (isSel || (it.isDoubt && !it.doubtResolved)) ? 10 : 0; ctx.shadowColor = "black";
                
                if(it.isDoubt && !it.doubtResolved) ctx.setLineDash([baseW*2, baseW*2]); else ctx.setLineDash([]);

                if(it.type === 'point') { ctx.beginPath(); ctx.arc(it.x, it.y, baseW*2.5, 0, Math.PI*2); ctx.fill(); } 
                else if (it.type === 'line') {
                    ctx.beginPath(); ctx.moveTo(it.x1, it.y1); ctx.lineTo(it.x2, it.y2); ctx.stroke();
                    ctx.beginPath(); ctx.arc(it.x2, it.y2, baseW*1.5, 0, Math.PI*2); ctx.fill();
                    if(it.widthVal && (isDoubtMode || isSel)) { ctx.font = (baseW*3)+"px Arial"; ctx.fillStyle = "white"; ctx.fillText(it.widthVal.toFixed(1)+"¬µm", (it.x1+it.x2)/2, (it.y1+it.y2)/2); }
                }
                else if (it.type === 'circle') { ctx.beginPath(); ctx.arc(it.x, it.y, it.r, 0, Math.PI*2); ctx.stroke(); }

                if(counts[it.catId] !== undefined) counts[it.catId]++;
            });
            
            ctx.setLineDash([]); ctx.shadowBlur = 0;

            if(mode === 'measure') {
                ctx.fillStyle = "#ff00ff";
                measurePoints.forEach((p,i) => {
                    ctx.beginPath(); ctx.arc(p.x, p.y, baseW*3, 0, Math.PI*2); ctx.fill();
                    ctx.font = (baseW*4)+"px Arial"; ctx.fillStyle="white"; ctx.fillText(i+1, p.x, p.y);
                });
            }

            let html = isCalibrated ? `<span style="color:#666; font-size:10px;">(1 ${unitName} = ${pixelsPerUnit.toFixed(1)}px)</span> | ` : `<span style="color:red">NO CALIB</span> | `;
            STATS_ORDER.forEach(k => { const c = CATS[k]; html += `<span style="color:${c.color}">${c.label}: ${counts[k]}</span> | `; });
            statsBar.innerHTML = html.slice(0, -3);
            return html; 
        }

        function exportExcel() {
            if(items.length===0) { alert("No data!"); return; }
            let counts={}; STATS_ORDER.forEach(k=>counts[k]=0);
            items.forEach(it=>{if(counts[it.catId]!==undefined)counts[it.catId]++});
            let headers = STATS_ORDER.map(k => CATS[k].label).join(",");
            let values = STATS_ORDER.map(k => counts[k]).join(",");
            let txt = `Unit: ${isCalibrated?unitName:'px'}\n` + headers + "\n" + values + "\n";
            const l=document.createElement('a'); l.href='data:text/csv;charset=utf-8,'+encodeURI(txt); l.download=currentFileName+"_counts.csv"; l.click();
        }

        function getMicrometers(px) { if(!isCalibrated) return 0; const val = px / pixelsPerUnit; if(unitName === 'mm') return val * 1000; if(unitName === 'm') return val * 1000000; if(unitName === 'nm') return val / 1000; return val; }
        function findItemAt(x, y) {
            const th = 20 / currentScale; const visibleItems = isDoubtMode ? items.filter(i => i.isDoubt) : items;
            for(let i = visibleItems.length - 1; i >= 0; i--) {
                const it = visibleItems[i];
                if(it.type === 'point') { if(Math.hypot(x-it.x, y-it.y) < th) return it; }
                else if(it.type === 'line') {
                    const A=x-it.x1; const B=y-it.y1; const C=it.x2-it.x1; const D=it.y2-it.y1; const lenSq = C*C+D*D; let param=-1;
                    if(lenSq!==0) param=(A*C+B*D)/lenSq; let xx,yy; if(param<0){xx=it.x1;yy=it.y1} else if(param>1){xx=it.x2;yy=it.y2} else{xx=it.x1+param*C;yy=it.y1+param*D}
                    if(Math.hypot(x-xx,y-yy)<th) return it;
                } else if(it.type === 'circle') { if(Math.abs(Math.hypot(x-it.x, y-it.y)-it.r) < th) return it; }
            } return null;
        }

        function toggleActionButtons(show) { const disp = show ? 'inline-block' : 'none'; document.getElementById('btnDelete').style.display = disp; if(show && selectedItem && selectedItem.type === 'line' && !isDoubtMode && !selectedItem.isDoubt) { document.getElementById('btnMarkDoubt').style.display = 'inline-block'; } else { document.getElementById('btnMarkDoubt').style.display = 'none'; } }
        
        // --- ZOOM FUNCTIONS ---
        function updateZoom(val) { 
            currentScale = val/100; 
            document.getElementById('zoomLabel').innerText = Math.round(val)+'%'; 
            document.getElementById('zoomSlider').value = val;
            if(img.src) { 
                cvs.style.width = (img.width*currentScale)+"px"; 
                cvs.style.height = (img.height*currentScale)+"px"; 
            } 
        }

        function changeZoom(delta) {
            let newVal = parseInt(zoomSlider.value) + delta;
            newVal = Math.max(10, Math.min(400, newVal));
            updateZoom(newVal);
        }

        function fitToScreen() {
            if(!img.src) return;
            const vw = viewport.clientWidth - 20; 
            const vh = viewport.clientHeight - 20;
            const ratioW = vw / img.width;
            const ratioH = vh / img.height;
            const bestRatio = Math.min(ratioW, ratioH);
            
            updateZoom(Math.floor(bestRatio * 100));
            // Center scroll
            viewport.scrollLeft = (cvs.scrollWidth - viewport.clientWidth) / 2;
            viewport.scrollTop = (cvs.scrollHeight - viewport.clientHeight) / 2;
        }

        function openCalibration() { document.getElementById('modalOverlay').style.display = 'flex'; }
        function closeModal() { document.getElementById('modalOverlay').style.display = 'none'; isDoubtMode = false; /*safety*/ setMode('pan'); }
        
        function startMeasureRef() { if(!img.src) return; closeModal(); setMode('measure'); measurePoints = []; alert("Click the two ends of the scale bar."); }
        function finishMeasureRef() {
            const d = Math.hypot(measurePoints[1].x - measurePoints[0].x, measurePoints[1].y - measurePoints[0].y);
            document.getElementById('modalOverlay').style.display='flex';
            document.getElementById('manualInputArea').style.opacity='1'; document.getElementById('manualInputArea').style.pointerEvents='auto';
            document.getElementById('pixelReadout').innerText = "px: " + d.toFixed(1);
            document.getElementById('manualInputArea').dataset.d = d;
            setMode('pan');
        }
        function applyManual() {
            const d = parseFloat(document.getElementById('manualInputArea').dataset.d); const val = parseFloat(document.getElementById('manInput').value); const unit = document.getElementById('manUnit').value;
            if(!val) return; pixelsPerUnit = d / val; unitName = unit; isCalibrated = true; closeModal(); redraw();
        }
        function applyFOV() { const val = parseFloat(document.getElementById('fovInput').value); const unit = document.getElementById('fovUnit').value; if(!val || !img.src) return; pixelsPerUnit = img.width/val; unitName = unit; isCalibrated = true; closeModal(); redraw(); }

        document.getElementById('inpFile').addEventListener('change', e => loadFile(e.target.files[0], false));
        document.getElementById('inpProject').addEventListener('change', e => loadProjectFile(e.target.files[0]));
        
        function loadFile(file, isProject, projectData) { 
            if(!file && !projectData) return; 
            if(file) {
                currentFileName = file.name.replace(/\.[^/.]+$/, "");
            }

            const r = new FileReader(); 
            r.onload = evt => { 
                const src = isProject ? projectData.imageSrc : evt.target.result; 
                img = new Image(); 
                img.onload = () => { 
                    cvs.style.display = 'block'; cvs.width = img.width; cvs.height = img.height; 
                    if(isProject) { 
                        items = projectData.items || []; 
                        if(projectData.calibration) { pixelsPerUnit=projectData.calibration.ppu; unitName=projectData.calibration.unit; isCalibrated=true; } 
                    } else { 
                        items=[]; isCalibrated=false; redoStack=[]; 
                    } 
                    fitToScreen(); 
                    setMode('pan'); redraw(); 
                }; 
                img.src = src; 
            }; 
            if(isProject) r.readAsText(new Blob([""])); else r.readAsDataURL(file); 
        }

        function loadProjectFile(f) { 
            currentFileName = f.name.replace(/\.[^/.]+$/, ""); 
            const r=new FileReader(); r.onload=e=>{try{loadFile(null,true,JSON.parse(e.target.result))}catch(err){alert("Err")}}; r.readAsText(f); 
        }

        function saveProject() { 
            if(!img.src)return; 
            const d={imageSrc:img.src,items:items,calibration:{ppu:pixelsPerUnit,unit:unitName},date:new Date().toISOString()}; 
            const b=new Blob([JSON.stringify(d)],{type:"application/json"}); 
            const l=document.createElement('a'); 
            l.download=currentFileName + ".json"; 
            l.href=URL.createObjectURL(b); l.click(); 
        }

        function downloadImg() { 
            if(!img.src)return; 
            const p=selectedItem; selectedItem=null; redraw(); 
            const l=document.createElement('a'); 
            l.download=currentFileName + "_samp.jpg"; 
            l.href=cvs.toDataURL('image/jpeg',0.9); l.click(); 
            selectedItem=p; redraw(); 
        }
        
        function downloadImgWithCounts() {
            if(!img.src) return;
            const p = selectedItem; selectedItem = null; 
            
            ctx.clearRect(0,0, cvs.width, cvs.height);
            ctx.drawImage(img, 0, 0);
            redraw(); 

            let counts = {}; STATS_ORDER.forEach(k => counts[k]=0);
            items.forEach(it=>{if(counts[it.catId]!==undefined)counts[it.catId]++});
            
            let statsText = `Calib: ${isCalibrated ? 'YES' : 'NO'} | `;
            STATS_ORDER.forEach(k => { statsText += `${CATS[k].label}: ${counts[k]} | `; });

            const H = cvs.height; const W = cvs.width;
            const barH = Math.max(30, H * 0.05); 
            ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
            ctx.fillRect(0, H - barH, W, barH);
            
            ctx.fillStyle = "black";
            ctx.font = "bold " + (barH * 0.5) + "px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(statsText, W/2, H - barH/2);

            const l = document.createElement('a');
            l.download = currentFileName + "_count.jpg";
            l.href = cvs.toDataURL('image/jpeg', 0.9);
            l.click();

            selectedItem = p;
            redraw();
        }

        function undo() { 
            if(items.length > 0) {
                const it = items.pop();
                redoStack.push(it);
                redraw();
            }
        }

        function redo() {
            if(redoStack.length > 0) {
                const it = redoStack.pop();
                items.push(it);
                redraw();
            }
        }

        function deleteSelected() { 
            if(selectedItem){
                items=items.filter(i=>i!==selectedItem); 
                selectedItem=null; toggleActionButtons(false); 
                redraw();
            }
        }
    </script>
</body>
</html>
